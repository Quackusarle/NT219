<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gi·∫£i M√£ B·∫£n Ghi Y T·∫ø</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.7/full/pyodide.js"></script>
    <style>
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #eef1f5;
        color: #333;
        line-height: 1.6;
      }
      .container {
        max-width: 900px;
        margin: 30px auto;
        background-color: #fff;
        padding: 20px 30px 30px 30px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }
      h2 {
        text-align: center;
        color: #2c3e50;
        margin-bottom: 30px;
        font-weight: 600;
      }
      .form-section {
        margin-bottom: 25px;
        padding-bottom: 25px;
        border-bottom: 1px solid #e0e0e0;
      }
      .form-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      .form-group {
        margin-bottom: 18px;
      }
      .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #495057;
        font-size: 0.95em;
      }
      .form-group input[type="text"],
      .form-group input[type="file"],
      .form-group textarea,
      .form-group select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid #ced4da;
        border-radius: 5px;
        box-sizing: border-box;
        font-size: 1em;
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
      }
      .form-group input[type="text"]:focus,
      .form-group input[type="file"]:focus,
      .form-group textarea:focus,
      .form-group select:focus {
        border-color: #80bdff;
        outline: 0;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      }
      .form-group textarea {
        resize: vertical;
        min-height: 120px;
      }
      button {
        display: inline-block;
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 500;
        transition: background-color 0.3s ease;
        margin-right: 10px;
        margin-top: 10px;
      }
      button:hover {
        background-color: #0056b3;
      }
      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      .message-area {
        margin-top: 20px;
        padding: 12px;
        border-radius: 5px;
        text-align: center;
        font-size: 0.95em;
      }
      .success {
        background-color: #d1e7dd;
        color: #0f5132;
        border: 1px solid #badbcc;
      }
      .error {
        background-color: #f8d7da;
        color: #842029;
        border: 1px solid #f5c2c7;
      }
      .info {
        background-color: #cff4fc;
        color: #055160;
        border-color: #b6effb;
      }
      .warning {
        background-color: #fff3cd;
        color: #664d03;
        border: 1px solid #ffecb5;
      }
      .file-upload-status {
        font-size: 0.9em;
        margin-left: 10px;
        color: #28a745;
      }
      .data-section {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin-top: 15px;
      }
      .data-section h4 {
        margin-top: 0;
        color: #495057;
      }
      .data-field {
        margin-bottom: 10px;
      }
      .data-field strong {
        color: #2c3e50;
      }
      .decrypted-content {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        padding: 15px;
        border-radius: 5px;
        margin-top: 15px;
      }
      .navigation-buttons {
        text-align: center;
        margin-bottom: 20px;
      }
      .navigation-buttons button {
        background-color: #6c757d;
        margin: 0 5px;
      }
      .navigation-buttons button:hover {
        background-color: #545b62;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h2>Gi·∫£i M√£ B·∫£n Ghi Y T·∫ø</h2>

      <div class="navigation-buttons">
        <button onclick="goBack()">‚Üê Quay L·∫°i Danh S√°ch</button>
        <button onclick="goHome()">üè† Trang Ch·ªß</button>
      </div>

      <div class="form-section">
        <h3>1. Th√¥ng Tin B·∫£n Ghi</h3>
        <div id="recordInfo" class="data-section">
          <div id="loadingRecord">ƒêang t·∫£i th√¥ng tin b·∫£n ghi...</div>
        </div>
      </div>

      <div class="form-section">
        <h3>2. Kh√≥a Gi·∫£i M√£</h3>
        <div class="form-group">
          <label for="publicKeyFile">T·∫£i l√™n file Public Key (.bin ho·∫∑c .json):</label>
          <input type="file" id="publicKeyFile" accept=".bin,.json" disabled />
          <span id="publicKeyStatus" class="file-upload-status"></span>
        </div>
        <div class="form-group">
          <label for="privateKeyFile">T·∫£i l√™n file Private Key (.bin ho·∫∑c .json):</label>
          <input type="file" id="privateKeyFile" accept=".bin,.json" disabled />
          <span id="privateKeyStatus" class="file-upload-status"></span>
        </div>
      </div>

      <div class="form-section">
        <h3>3. Gi·∫£i M√£</h3>
        <button id="decryptButton" onclick="decryptRecord()" disabled>Gi·∫£i M√£ N·ªôi Dung</button>
        
        <div id="decryptedResult" class="decrypted-content" style="display: none;">
          <h4>N·ªôi dung ƒë√£ gi·∫£i m√£:</h4>
          <div id="decryptedContent"></div>
        </div>
      </div>

      <div id="submissionStatus" class="message-area" style="display: none;"></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-content">
        <div class="spinner"></div>
        <h3>ƒêang kh·ªüi t·∫°o h·ªá th·ªëng gi·∫£i m√£...</h3>
        <p id="loadingStatus">ƒêang t·∫£i Pyodide v√† th∆∞ vi·ªán Charm-Crypto</p>
      </div>
    </div>

    <style>
      .loading-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 9999;
        color: white;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      .loading-overlay.show {
        display: flex;
      }
      .loading-content {
        text-align: center;
      }
      .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>

    <script>
      // --- DOM Elements ---
      const recordInfo = document.getElementById("recordInfo");
      const publicKeyFileInput = document.getElementById("publicKeyFile");
      const publicKeyStatus = document.getElementById("publicKeyStatus");
      const privateKeyFileInput = document.getElementById("privateKeyFile");
      const privateKeyStatus = document.getElementById("privateKeyStatus");
      const decryptButton = document.getElementById("decryptButton");
      const decryptedResult = document.getElementById("decryptedResult");
      const decryptedContent = document.getElementById("decryptedContent");
      const statusMessageElement = document.getElementById("submissionStatus");

      // --- Global State ---
      let pyodide = null;
      let publicKeyObject = null;
      let privateKeyObject = null;
      let currentRecord = null;

      // --- API URLs ---
      const RETRIEVE_API_URL = "/api/ehr/";

      // --- Helper Functions ---
      function displayStatus(message, type = "info") {
        statusMessageElement.textContent = message;
        statusMessageElement.className = `message-area ${type}`;
        statusMessageElement.style.display = "block";
      }

      function arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = "";
        for (let i = 0; i < bytes.byteLength; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        try {
          return window.btoa(binary);
        } catch (error) {
          console.warn("btoa failed, using alternative encoding");
          const binaryString = Array.from(bytes, (byte) =>
            String.fromCharCode(byte)
          ).join("");
          return btoa(unescape(encodeURIComponent(binaryString)));
        }
      }

      function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      }

      function goBack() {
        window.history.back();
      }

      function goHome() {
        window.location.href = "/";
      }



      function getDataTypeDisplayName(dataType) {
        const typeMap = {
          'CONSULTATION_NOTE': 'Ghi ch√∫ kh√°m b·ªánh',
          'LAB_RESULT_SUMMARY': 'T√≥m t·∫Øt KQ X√©t nghi·ªám',
          'TREATMENT_PLAN': 'K·∫ø ho·∫°ch ƒëi·ªÅu tr·ªã',
          'OTHER_SENSITIVE_NOTE': 'Ghi ch√∫ nh·∫°y c·∫£m kh√°c'
        };
        return typeMap[dataType] || dataType;
      }

      // --- Get Record ID from URL ---
      function getRecordIdFromURL() {
        const path = window.location.pathname;
        // Updated regex to handle URL with or without trailing slash
        const match = path.match(/\/decrypt-record\/([^\/]+)\/?/);
        return match ? match[1] : null;
      }

      // --- Pyodide Initialization (same as upload) ---
      async function initializePyodide() {
        // Show loading overlay
        const loadingOverlay = document.getElementById("loadingOverlay");
        const loadingStatus = document.getElementById("loadingStatus");
        
        // Check if elements exist (they might be removed if error page was shown)
        if (!loadingOverlay || !loadingStatus) {
          console.log("Loading overlay elements not found, skipping Pyodide initialization");
          return;
        }
        
        loadingOverlay.classList.add("show");
        
        try {
          loadingStatus.textContent = "ƒêang t·∫£i Pyodide...";
          
          // Load Pyodide (·∫©n stdout/stderr logs)
          pyodide = await loadPyodide({
            stdout: () => {}, // ·∫®n logs
            stderr: () => {}, // ·∫®n error logs
          });

          loadingStatus.textContent = "ƒêang t·∫£i micropip...";
          await pyodide.loadPackage("micropip");
          const micropip = pyodide.pyimport("micropip");

          loadingStatus.textContent = "ƒêang c√†i ƒë·∫∑t Charm-Crypto...";
          const charmWheelURL = "https://quackusarle.github.io/charm_crypto_wheel_for_pyodide/charm_crypto-0.50-cp312-cp312-pyodide_2024_0_wasm32.whl";
          await micropip.install(charmWheelURL);

          loadingStatus.textContent = "ƒêang kh·ªüi t·∫°o h·ªá th·ªëng CP-ABE...";
          // Initialize CP-ABE system same as upload template
          await pyodide.runPythonAsync(`
from charm.toolbox.pairinggroup import PairingGroup
from charm.schemes.abenc.waters11 import Waters11

group = PairingGroup('SS512')
waters_abe = Waters11(group, uni_size=100)

globals()['_waters11_abe_scheme'] = waters_abe
globals()['_waters11_group'] = group
`);

          // Test initialization
          const testResult = await pyodide.runPythonAsync(`
result = "SUCCESS"
try:
    _waters11_abe_scheme
    _waters11_group
except NameError as e:
    result = f"FAILED: {str(e)}"
except Exception as e:
    result = f"ERROR: {str(e)}"
result
`);

          if (testResult !== "SUCCESS") {
            throw new Error(`L·ªói kh·ªüi t·∫°o Waters11: ${testResult}`);
          }

          // ·∫®n loading overlay
          loadingOverlay.classList.remove("show");
          
          // Pyodide ready, enable file inputs
          publicKeyFileInput.disabled = false;
          privateKeyFileInput.disabled = false;
        } catch (error) {
          // ·∫®n loading overlay khi c√≥ l·ªói
          loadingOverlay.classList.remove("show");
          
          console.error("L·ªói kh·ªüi t·∫°o Pyodide ho·∫∑c Charm:", error);
          displayStatus(`L·ªói kh·ªüi t·∫°o th∆∞ vi·ªán gi·∫£i m√£: ${error.message}`, "error");
        }
      }

      // --- Record Loading ---
      async function loadRecordById(recordId) {
        displayStatus("ƒêang t·∫£i b·∫£n ghi...", "info");
        try {
          const accessToken = localStorage.getItem("mainServer_accessToken");
          
          if (!accessToken) {
            displayStatus("Kh√¥ng t√¨m th·∫•y token x√°c th·ª±c. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.", "error");
            recordInfo.innerHTML = `
              <div style="color: #842029; text-align: center;">
                <h4>‚ùå Ch∆∞a ƒêƒÉng Nh·∫≠p</h4>
                <p>Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ truy c·∫≠p b·∫£n ghi n√†y.</p>
                <a href="/accounts/login/" style="display: inline-block; padding: 12px 24px; background-color: #007bff; color: white; text-decoration: none; border-radius: 5px; margin-top: 10px;">ƒêƒÉng Nh·∫≠p</a>
              </div>
            `;
            return;
          }

          const response = await fetch(`${RETRIEVE_API_URL}${recordId}/`, {
            method: "GET",
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          });

          if (response.ok) {
            const record = await response.json();
            currentRecord = record;
            displayRecordInfo(record);
            displayStatus("B·∫£n ghi ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng.", "success");
            updateDecryptButtonState();
                    } else if (response.status === 403) {
            // 403 Forbidden - kh√¥ng c√≥ quy·ªÅn truy c·∫≠p
            const errorData = await response.json();
            // Redirect t·ªõi error page thay v√¨ thay th·∫ø HTML
            const errorMessage = encodeURIComponent(errorData.detail || errorData.error || "Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p b·∫£n ghi n√†y.");
            window.location.href = `/error-access-denied/?message=${errorMessage}&record_id=${recordId}`;
            return; // D·ª´ng x·ª≠ l√Ω
          } else {
            const errorData = await response.json();
            displayStatus(`L·ªói t·∫£i b·∫£n ghi: ${errorData.error || "Unknown error"}`, "error");
            recordInfo.innerHTML = `
              <div style="color: #842029; text-align: center;">
                <h4>‚ùå L·ªói T·∫£i B·∫£n Ghi</h4>
                <p>${errorData.error || "Kh√¥ng th·ªÉ t·∫£i b·∫£n ghi"}</p>
                <button onclick="goBack()">Quay L·∫°i</button>
              </div>
            `;
          }
        } catch (error) {
          console.error("Error loading record:", error);
          displayStatus("L·ªói k·∫øt n·ªëi khi t·∫£i b·∫£n ghi.", "error");
          recordInfo.innerHTML = `
            <div style="color: #842029; text-align: center;">
              <h4>‚ùå L·ªói K·∫øt N·ªëi</h4>
              <p>Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server ƒë·ªÉ t·∫£i b·∫£n ghi.</p>
              <button onclick="goBack()">Quay L·∫°i</button>
            </div>
          `;
        }
      }

      function displayRecordInfo(record) {
        recordInfo.innerHTML = `
          <h4>Th√¥ng Tin B·∫£n Ghi</h4>
          <div class="data-field"><strong>ID:</strong> ${record.id}</div>
          <div class="data-field"><strong>M√£ B·ªánh Nh√¢n:</strong> ${record.patient_id_on_rs}</div>
          <div class="data-field"><strong>M√¥ T·∫£:</strong> ${record.description}</div>
          <div class="data-field"><strong>Lo·∫°i D·ªØ Li·ªáu:</strong> ${getDataTypeDisplayName(record.data_type)}</div>
          <div class="data-field"><strong>Ng√†y T·∫°o:</strong> ${new Date(record.created_at).toLocaleString('vi-VN')}</div>
        `;
      }

      // --- Public Key Handling (same pattern as upload) ---
      publicKeyFileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) {
          publicKeyStatus.textContent = "Ch∆∞a ch·ªçn file.";
          publicKeyObject = null;
          updateDecryptButtonState();
          return;
        }

        if (!pyodide) {
          displayStatus("Th∆∞ vi·ªán gi·∫£i m√£ ch∆∞a s·∫µn s√†ng.", "error");
          publicKeyObject = null;
          updateDecryptButtonState();
          return;
        }

        publicKeyStatus.textContent = `ƒêang ƒë·ªçc file: ${file.name}...`;
        try {
          let publicKeyData = null;

          if (file.name.endsWith(".json")) {
            const fileText = await file.text();
            try {
              publicKeyData = JSON.parse(fileText);
              if (!publicKeyData || typeof publicKeyData !== "object") {
                throw new Error("Public key JSON kh√¥ng h·ª£p l·ªá");
              }
            } catch (parseError) {
              throw new Error(`File JSON kh√¥ng h·ª£p l·ªá: ${parseError.message}`);
            }
          } else {
            // Binary format - use same approach as upload template
            const fileBuffer = await file.arrayBuffer();
            const pkBytes = new Uint8Array(fileBuffer);



            const result = await pyodide.runPythonAsync(`
import base64
import json
from charm.core.engine.util import bytesToObject

result_data = None
error_info = None

try:
    pk_bytes_list = ${JSON.stringify(Array.from(pkBytes))}
    pk_bytes = bytes(pk_bytes_list)
    
    print(f"Received {len(pk_bytes)} bytes for public key deserialization")
    
    if '_waters11_group' not in globals():
        raise Exception("Waters11 group not initialized")
        
    group = _waters11_group
    pk_obj = bytesToObject(pk_bytes, group)
    
    globals()['_global_public_key_object'] = pk_obj
    
    pk_info = {
        "keys": list(pk_obj.keys()) if hasattr(pk_obj, 'keys') else [],
        "status": "loaded",
        "type": "charm_pk_object"
    }
    
    result_data = pk_info
    print(f"Successfully loaded public key")
    
except Exception as e:
    error_info = str(e)
    print(f"Error deserializing public key: {e}")
    import traceback
    print(f"Traceback: {traceback.format_exc()}")

if result_data:
    result = json.dumps(result_data)
else:
    result = json.dumps({"error": error_info or "Unknown error"})

result
`);

            const parsedResult = JSON.parse(result);
            if (parsedResult.error) {
              throw new Error(`Python error: ${parsedResult.error}`);
            }

            publicKeyData = parsedResult;
          }

          publicKeyObject = publicKeyData;
          publicKeyStatus.textContent = `ƒê√£ t·∫£i Public Key: ${file.name}`;
          publicKeyStatus.style.color = "green";
          displayStatus("Public Key ƒë√£ s·∫µn s√†ng.", "success");
          updateDecryptButtonState();

        } catch (error) {
          console.error("L·ªói x·ª≠ l√Ω Public Key:", error);
          publicKeyStatus.textContent = `L·ªói: ${error.message}`;
          publicKeyStatus.style.color = "red";
          publicKeyObject = null;
          updateDecryptButtonState();
          displayStatus(`L·ªói x·ª≠ l√Ω public key: ${error.message}`, "error");
        }
      });

      // --- Private Key Handling (same pattern as upload) ---
      privateKeyFileInput.addEventListener("change", async (event) => {
        const file = event.target.files[0];
        if (!file) {
          privateKeyStatus.textContent = "Ch∆∞a ch·ªçn file.";
          privateKeyObject = null;
          updateDecryptButtonState();
          return;
        }

        if (!pyodide) {
          displayStatus("Th∆∞ vi·ªán gi·∫£i m√£ ch∆∞a s·∫µn s√†ng.", "error");
          privateKeyObject = null;
          updateDecryptButtonState();
          return;
        }

        privateKeyStatus.textContent = `ƒêang ƒë·ªçc file: ${file.name}...`;
        try {
          let privateKeyData = null;

          if (file.name.endsWith(".json")) {
            const fileText = await file.text();
            try {
              privateKeyData = JSON.parse(fileText);
              if (!privateKeyData || typeof privateKeyData !== "object") {
                throw new Error("Private key JSON kh√¥ng h·ª£p l·ªá");
              }
            } catch (parseError) {
              throw new Error(`File JSON kh√¥ng h·ª£p l·ªá: ${parseError.message}`);
            }
          } else {
            // Binary format - use same approach as upload template
            const fileBuffer = await file.arrayBuffer();
            const skBytes = new Uint8Array(fileBuffer);



            const result = await pyodide.runPythonAsync(`
import base64
import json
from charm.core.engine.util import bytesToObject

result_data = None
error_info = None

try:
    sk_bytes_list = ${JSON.stringify(Array.from(skBytes))}
    sk_bytes = bytes(sk_bytes_list)
    
    print(f"Received {len(sk_bytes)} bytes for private key deserialization")
    
    if '_waters11_group' not in globals():
        raise Exception("Waters11 group not initialized")
        
    group = _waters11_group
    sk_obj = bytesToObject(sk_bytes, group)
    
    globals()['_global_private_key_object'] = sk_obj
    
    sk_info = {
        "keys": list(sk_obj.keys()) if hasattr(sk_obj, 'keys') else [],
        "status": "loaded",
        "type": "charm_sk_object"
    }
    
    result_data = sk_info
    print(f"Successfully loaded private key")
    
except Exception as e:
    error_info = str(e)
    print(f"Error deserializing private key: {e}")
    import traceback
    print(f"Traceback: {traceback.format_exc()}")

if result_data:
    result = json.dumps(result_data)
else:
    result = json.dumps({"error": error_info or "Unknown error"})

result
`);

            const parsedResult = JSON.parse(result);
            if (parsedResult.error) {
              throw new Error(`Python error: ${parsedResult.error}`);
            }

            privateKeyData = parsedResult;
          }

          privateKeyObject = privateKeyData;
          privateKeyStatus.textContent = `ƒê√£ t·∫£i Private Key: ${file.name}`;
          privateKeyStatus.style.color = "green";
          displayStatus("Private Key ƒë√£ s·∫µn s√†ng.", "success");
          updateDecryptButtonState();

        } catch (error) {
          console.error("L·ªói x·ª≠ l√Ω Private Key:", error);
          privateKeyStatus.textContent = `L·ªói: ${error.message}`;
          privateKeyStatus.style.color = "red";
          privateKeyObject = null;
          updateDecryptButtonState();
          displayStatus(`L·ªói x·ª≠ l√Ω private key: ${error.message}`, "error");
        }
      });

      function updateDecryptButtonState() {
        const hasPublicKey = publicKeyObject !== null;
        const hasPrivateKey = privateKeyObject !== null;
        const hasRecord = currentRecord !== null;
        
        decryptButton.disabled = !hasPublicKey || !hasPrivateKey || !hasRecord || !pyodide;
        
        if (!hasRecord) {
          decryptButton.textContent = "ƒêang t·∫£i record...";
        } else if (!hasPublicKey) {
          decryptButton.textContent = "C·∫ßn Public Key ƒë·ªÉ gi·∫£i m√£";
        } else if (!hasPrivateKey) {
          decryptButton.textContent = "C·∫ßn Private Key ƒë·ªÉ gi·∫£i m√£";
        } else if (!pyodide) {
          decryptButton.textContent = "ƒêang kh·ªüi t·∫°o h·ªá th·ªëng...";
        } else {
          decryptButton.textContent = "Gi·∫£i M√£ N·ªôi Dung";
        }
      }

      // --- File Handling Helper Functions ---
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      function downloadCurrentFile() {
        if (!window.currentDecryptedUrl || !window.currentDownloadName) {
          displayStatus("L·ªói: Kh√¥ng t√¨m th·∫•y file ƒë·ªÉ t·∫£i v·ªÅ!", "error");
          return;
        }
        
        const a = document.createElement('a');
        a.href = window.currentDecryptedUrl;
        a.download = window.currentDownloadName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        displayStatus("File ƒë√£ ƒë∆∞·ª£c t·∫£i v·ªÅ!", "success");
      }

      function previewCurrentFile() {
        if (!window.currentDecryptedUrl || !window.currentFileType) {
          displayStatus("L·ªói: Kh√¥ng t√¨m th·∫•y file ƒë·ªÉ xem tr∆∞·ªõc!", "error");
          return;
        }
        
        const previewDiv = document.getElementById('filePreview');
        const url = window.currentDecryptedUrl;
        const fileType = window.currentFileType;
        
        console.log(`Previewing file type: ${fileType}`);
        
        if (fileType === "image") {
          previewDiv.innerHTML = `
            <div style="text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
              <h6>üñºÔ∏è Xem tr∆∞·ªõc ·∫£nh:</h6>
              <img src="${url}" alt="Decrypted Image" style="max-width: 100%; max-height: 400px; border-radius: 5px;" 
                   onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
              <div style="display: none; color: #dc3545;">‚ùå Kh√¥ng th·ªÉ hi·ªÉn th·ªã ·∫£nh n√†y</div>
            </div>
          `;
        } else if (fileType === "document") {
          previewDiv.innerHTML = `
            <div style="text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
              <h6>üìÑ Xem tr∆∞·ªõc t√†i li·ªáu:</h6>
              <iframe src="${url}" style="width: 100%; height: 400px; border: none; border-radius: 5px;" 
                      onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
              </iframe>
              <div style="display: none; color: #dc3545;">‚ùå Kh√¥ng th·ªÉ hi·ªÉn th·ªã t√†i li·ªáu n√†y trong tr√¨nh duy·ªát</div>
            </div>
          `;
        } else {
          // For other file types, try to display as text if small enough
          if (window.currentDecryptedBlob && window.currentDecryptedBlob.size < 50000) {
            const reader = new FileReader();
            reader.onload = function(e) {
              try {
                const text = e.target.result;
                previewDiv.innerHTML = `
                  <div style="border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
                    <h6>üìÑ Xem tr∆∞·ªõc n·ªôi dung text:</h6>
                    <pre style="background-color: #f8f9fa; padding: 10px; border-radius: 3px; white-space: pre-wrap; max-height: 300px; overflow-y: auto;">${text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
                  </div>
                `;
              } catch (error) {
                previewDiv.innerHTML = `
                  <div style="text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px; color: #6c757d;">
                    <h6>üìÅ File nh·ªã ph√¢n</h6>
                    <p>Kh√¥ng th·ªÉ xem tr∆∞·ªõc lo·∫°i file n√†y. Vui l√≤ng t·∫£i v·ªÅ ƒë·ªÉ m·ªü b·∫±ng ·ª©ng d·ª•ng ph√π h·ª£p.</p>
                  </div>
                `;
              }
            };
            reader.readAsText(window.currentDecryptedBlob);
          } else {
            previewDiv.innerHTML = `
              <div style="text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px; color: #6c757d;">
                <h6>üìÅ File l·ªõn</h6>
                <p>File qu√° l·ªõn ƒë·ªÉ xem tr∆∞·ªõc. Vui l√≤ng t·∫£i v·ªÅ ƒë·ªÉ m·ªü b·∫±ng ·ª©ng d·ª•ng ph√π h·ª£p.</p>
              </div>
            `;
          }
        }
      }

      // --- Decryption Logic ---
      async function decryptRecord() {
        if (!currentRecord || !publicKeyObject || !privateKeyObject || !pyodide) {
          displayStatus("Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt ƒë·ªÉ gi·∫£i m√£ (c·∫ßn Public Key, Private Key v√† record).", "error");
          return;
        }

        displayStatus("ƒêang gi·∫£i m√£...", "info");
        decryptButton.disabled = true;

        try {
          const result = await pyodide.runPythonAsync(`
from charm.toolbox.pairinggroup import GT, G1, G2, ZR
import base64
import json
import hashlib
from charm.core.engine.util import bytesToObject

print("Starting decryption process...")
final_result = None

try:
    # Check required objects
    if '_waters11_abe_scheme' not in globals():
        raise Exception("Waters11 ABE scheme not initialized")
    if '_waters11_group' not in globals():
        raise Exception("Waters11 group not initialized")
    if '_global_private_key_object' not in globals():
        raise Exception("Private key not loaded")

    waters_abe = _waters11_abe_scheme
    group = _waters11_group
    sk = _global_private_key_object

    # Deserialize the ciphertext
    encrypted_kek_b64 = "${currentRecord.encrypted_kek_b64}"
    ciphertext_bytes = base64.b64decode(encrypted_kek_b64)
    ciphertext = bytesToObject(ciphertext_bytes, group)
    
    print(f"Ciphertext keys: {list(ciphertext.keys())}")
    
    # Fix policy structure if needed
    # During encryption, policy was converted to string to avoid BinNode serialization issues
    # Now we need to convert it back to policy tree for decryption
    if 'policy' in ciphertext and isinstance(ciphertext['policy'], str):
        print("Converting string policy back to tree structure...")
        policy_tree = waters_abe.util.createPolicy(ciphertext['policy'])
        ciphertext['policy'] = policy_tree
        print("‚úì Policy tree reconstructed")
    elif 'policy' not in ciphertext:
        raise Exception("Ciphertext missing required 'policy' key")

    # Validate private key structure
    if not isinstance(sk, dict) or 'attr_list' not in sk:
        raise Exception("Private key invalid or missing 'attr_list' field")

    # Get public key and perform CP-ABE decryption
    if '_global_public_key_object' not in globals():
        raise Exception("Public key not loaded")
    
    pk = _global_public_key_object
    print("Performing CP-ABE decryption...")
    gt_message = waters_abe.decrypt(pk, ciphertext, sk)
    print("‚úì CP-ABE decryption successful")

    # Derive the AES key from GT message
    web_crypto_key_bytes = hashlib.sha256(group.serialize(gt_message)).digest()
    web_crypto_key_base64 = base64.b64encode(web_crypto_key_bytes).decode('utf-8')
    
    final_result = {
        "aes_key_base64": web_crypto_key_base64,
        "status": "success"
    }
    
    print("‚úì AES key derived successfully")

except Exception as e:
    print(f"Decryption failed: {e}")
    import traceback
    print(f"Traceback: {traceback.format_exc()}")
    final_result = {"error": str(e)}

json.dumps(final_result)
`);

          const parsedResult = JSON.parse(result);
          
          if (parsedResult.error) {
            throw new Error(parsedResult.error);
          }
         
          // Now decrypt the content with AES
          const aesKeyBytes = base64ToArrayBuffer(parsedResult.aes_key_base64);
          const aesKey = await crypto.subtle.importKey(
            "raw",
            aesKeyBytes,
            { name: "AES-GCM" },
            false,
            ["decrypt"]
          );

          const iv = base64ToArrayBuffer(currentRecord.aes_iv_b64);
          const encryptedContent = base64ToArrayBuffer(currentRecord.encrypted_main_content_b64);

          const decryptedBuffer = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv },
            aesKey,
            encryptedContent
          );

          // Smart detection: Check if this is binary file data or text data
          let isTextData = true;
          let displayContent = "";
          
          const contentSize = decryptedBuffer.byteLength;
          console.log(`Decrypted content size: ${contentSize} bytes`);
          
          // Calculate entropy to detect encrypted vs plaintext content
          const bytes = new Uint8Array(decryptedBuffer);
          const byteFreq = new Array(256).fill(0);
          for (let i = 0; i < bytes.length; i++) {
            byteFreq[bytes[i]]++;
          }
          const uniqueBytes = byteFreq.filter(f => f > 0).length;
          const entropy = uniqueBytes / 256;
          console.log(`Content entropy: ${entropy.toFixed(3)} (0-1, higher = more random)`);
          
          // Detection logic based on size, entropy, and description
          const description = currentRecord.description.toLowerCase();
          const isLargeContent = contentSize > 500000; // > 500KB
          const isHighEntropy = entropy > 0.8; // High randomness (encrypted)
          const hasFileKeywords = description.includes('x√©t nghi·ªám') || 
                                   description.includes('·∫£nh') || 
                                   description.includes('h√¨nh') ||
                                   description.includes('pdf') ||
                                   description.includes('k·∫øt qu·∫£');
          
          console.log(`Detection factors: large=${isLargeContent}, highEntropy=${isHighEntropy}, fileKeywords=${hasFileKeywords}`);
          
          if (isLargeContent || (isHighEntropy && hasFileKeywords)) {
            // Treat as binary file
            isTextData = false;
            console.log("Detected as BINARY FILE");
          } else {
            // Try to decode as text
            try {
              const decryptedText = new TextDecoder("utf-8", { fatal: true }).decode(decryptedBuffer);
              
              // Additional text validation
              const nonPrintableRatio = (decryptedText.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g) || []).length / decryptedText.length;
              const hasReadableText = /[a-zA-Z\u00C0-\u024F\u1E00-\u1EFF]/.test(decryptedText); // Latin + Vietnamese
              
              if (nonPrintableRatio > 0.1 || !hasReadableText) {
                isTextData = false;
                console.log("Invalid text content, treating as file");
              } else {
                displayContent = decryptedText;
                isTextData = true;
                console.log("Valid TEXT content detected");
              }
            } catch (e) {
              isTextData = false;
              console.log("Text decoding failed, treating as file");
            }
          }
          
          // Display the decrypted content based on type
          if (isTextData) {
            // Check if this might be base64-encoded binary data
            try {
              const textContent = new TextDecoder("utf-8").decode(decryptedBuffer);
              
              // Check if content looks like base64 and starts with common file signatures
              const base64Pattern = /^[A-Za-z0-9+/]+=*$/;
              const isLikelyBase64 = base64Pattern.test(textContent.replace(/\s/g, ''));
              const startsWithZipB64 = textContent.startsWith('UEsD'); // ZIP signature in base64
              const startsWithPdfB64 = textContent.startsWith('JVBER'); // %PDF signature in base64
              const isLargeBase64 = textContent.length > 100000; // Large base64 content
              
              console.log(`Base64 detection: isLikelyBase64=${isLikelyBase64}, startsWithZip=${startsWithZipB64}, startsWithPdf=${startsWithPdfB64}, isLarge=${isLargeBase64}`);
              
              if (isLikelyBase64 && (startsWithZipB64 || startsWithPdfB64 || isLargeBase64)) {
                console.log("Detected base64-encoded binary data, attempting decode...");
                
                try {
                  // Try to decode base64
                  const binaryData = Uint8Array.from(atob(textContent), c => c.charCodeAt(0));
                  console.log(`Base64 decoded to ${binaryData.length} bytes`);
                  
                  // Now treat this as binary data
                  const fileSize = binaryData.length;
                  const fileSizeFormatted = formatFileSize(fileSize);
                  
                  // Check file signature on decoded data
                  const firstBytes = binaryData.slice(0, 10);
                  const fileSignature = Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join('');
                  
                  console.log(`Decoded file signature: ${fileSignature}`);
                  console.log(`Decoded first 4 bytes as string: ${String.fromCharCode(...firstBytes.slice(0, 4))}`);
                  
                  // Enhanced detection on decoded data
                  const isPDF = String.fromCharCode(...firstBytes.slice(0, 4)) === '%PDF';
                  const isJPEG = firstBytes[0] === 0xFF && firstBytes[1] === 0xD8;
                  const isPNG = firstBytes[0] === 0x89 && firstBytes[1] === 0x50 && firstBytes[2] === 0x4E && firstBytes[3] === 0x47;
                  const isZIP = String.fromCharCode(...firstBytes.slice(0, 4)) === 'PK\x03\x04';
                  
                  console.log(`Decoded file type detection: PDF=${isPDF}, JPEG=${isJPEG}, PNG=${isPNG}, ZIP=${isZIP}`);
                  
                  let fileType = "unknown";
                  let downloadName = "decrypted_file";
                  let mimeType = "application/octet-stream";
                  
                  if (isPDF) {
                    fileType = "pdf_document";
                    downloadName = `decrypted_document_${Date.now()}.pdf`;
                    mimeType = "application/pdf";
                  } else if (isJPEG) {
                    fileType = "image";
                    downloadName = `decrypted_image_${Date.now()}.jpg`;
                    mimeType = "image/jpeg";
                  } else if (isPNG) {
                    fileType = "image";
                    downloadName = `decrypted_image_${Date.now()}.png`;
                    mimeType = "image/png";
                  } else if (isZIP) {
                    // ZIP could be Office document
                    const description = currentRecord.description.toLowerCase();
                    if (description.includes('x√©t nghi·ªám') || description.includes('k·∫øt qu·∫£') || description.includes('document')) {
                      fileType = "office_document";
                      downloadName = `decrypted_document_${Date.now()}.docx`;
                      mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                    } else {
                      fileType = "archive";
                      downloadName = `decrypted_archive_${Date.now()}.zip`;
                      mimeType = "application/zip";
                    }
                  } else {
                    // Fallback based on description
                    const description = currentRecord.description.toLowerCase();
                    if (description.includes('x√©t nghi·ªám') || description.includes('k·∫øt qu·∫£')) {
                      fileType = "medical_report";
                      downloadName = `medical_report_${Date.now()}.docx`;
                      mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
                    }
                  }
                  
                  // Create blob with decoded binary data
                  const blob = new Blob([binaryData], { type: mimeType });
                  const url = URL.createObjectURL(blob);
                  
                  // Store globally for button handlers
                  window.currentDecryptedBlob = blob;
                  window.currentDecryptedUrl = url;
                  window.currentFileType = fileType;
                  window.currentDownloadName = downloadName;
                  
                  decryptedContent.innerHTML = `
                    <h5>üéâ File ƒë√£ gi·∫£i m√£ th√†nh c√¥ng! (Base64 decoded)</h5>
                    <div style="background-color: white; padding: 15px; border-radius: 5px; border: 1px solid #c3e6cb;">
                      <div style="margin-bottom: 15px;">
                        <strong>üìÅ Lo·∫°i file:</strong> ${fileType.toUpperCase().replace(/_/g, ' ')}<br>
                        <strong>üìè K√≠ch th∆∞·ªõc:</strong> ${fileSizeFormatted}<br>
                        <strong>üìÑ M√¥ t·∫£ g·ªëc:</strong> ${currentRecord.description}<br>
                        <strong>üè∑Ô∏è Data Type:</strong> ${currentRecord.data_type}<br>
                        <strong>üîó MIME Type:</strong> ${mimeType}<br>
                        <strong>üîÑ Encoding:</strong> Base64 ‚Üí Binary<br>
                        <strong>üìÖ T·∫°o l√∫c:</strong> ${new Date(currentRecord.created_at).toLocaleString('vi-VN')}
                      </div>
                      
                      <div style="margin-bottom: 15px;">
                        <button onclick="downloadCurrentFile()" 
                                style="background-color: #28a745; padding: 10px 20px; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                          üíæ T·∫£i v·ªÅ file ƒë√£ gi·∫£i m√£
                        </button>
                        
                        <button onclick="previewCurrentFile()" 
                                style="background-color: #17a2b8; padding: 10px 20px; color: white; border: none; border-radius: 5px; cursor: pointer;">
                          üëÅÔ∏è Xem tr∆∞·ªõc (n·∫øu c√≥ th·ªÉ)
                        </button>
                      </div>
                      
                      <div id="filePreview" style="margin-top: 15px;"></div>
                    </div>
                  `;
                  
                  // Skip the normal binary handling since we handled it here
                  decryptedResult.style.display = "block";
                  displayStatus("Gi·∫£i m√£ th√†nh c√¥ng! (Base64 decoded)", "success");
                  return; // Exit early
                  
                } catch (base64Error) {
                  console.log("Base64 decode failed, treating as regular text:", base64Error);
                }
              }
            } catch (e) {
              console.log("Text content analysis failed:", e);
            }
            
            // Regular text content display
            decryptedContent.innerHTML = `
              <h5>N·ªôi dung vƒÉn b·∫£n ƒë√£ gi·∫£i m√£:</h5>
              <div style="background-color: white; padding: 15px; border-radius: 5px; border: 1px solid #c3e6cb; white-space: pre-wrap;">
                ${displayContent.replace(/</g, '&lt;').replace(/>/g, '&gt;')}
              </div>
            `;
          } else {
            // Binary file content
            const fileSize = decryptedBuffer.byteLength;
            const fileSizeFormatted = formatFileSize(fileSize);
            
            // Enhanced file type detection
            const description = currentRecord.description.toLowerCase();
            let fileType = "unknown";
            let downloadName = "decrypted_file";
            let mimeType = "application/octet-stream";
            
            // Check file signature (magic numbers) for better detection
            const firstBytes = new Uint8Array(decryptedBuffer.slice(0, 10));
            const fileSignature = Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            
            console.log(`File signature: ${fileSignature}`);
            console.log(`First 4 bytes as string: ${String.fromCharCode(...firstBytes.slice(0, 4))}`);
            
            // PDF detection: %PDF signature
            const isPDF = String.fromCharCode(...firstBytes.slice(0, 4)) === '%PDF';
            
            // JPEG detection: FF D8 signature
            const isJPEG = firstBytes[0] === 0xFF && firstBytes[1] === 0xD8;
            
            // PNG detection: 89 50 4E 47 signature
            const isPNG = firstBytes[0] === 0x89 && firstBytes[1] === 0x50 && firstBytes[2] === 0x4E && firstBytes[3] === 0x47;
            
            console.log(`File type detection: PDF=${isPDF}, JPEG=${isJPEG}, PNG=${isPNG}`);
            
            // More sophisticated detection based on signature first, then description and size
            if (isPDF) {
              fileType = "pdf_document";
              downloadName = `decrypted_document_${Date.now()}.pdf`;
              mimeType = "application/pdf";
            } else if (isJPEG) {
              fileType = "image";
              downloadName = `decrypted_image_${Date.now()}.jpg`;
              mimeType = "image/jpeg";
            } else if (isPNG) {
              fileType = "image";
              downloadName = `decrypted_image_${Date.now()}.png`;
              mimeType = "image/png";
            } else if (description.includes("·∫£nh") || description.includes("h√¨nh") || description.includes("image") || description.includes("photo")) {
              fileType = "image";
              downloadName = `decrypted_image_${Date.now()}.jpg`;
              mimeType = "image/jpeg";
            } else if (description.includes("pdf") || description.includes("t√†i li·ªáu") || description.includes("document")) {
              fileType = "pdf_document";
              downloadName = `decrypted_document_${Date.now()}.pdf`;
              mimeType = "application/pdf";
            } else if (description.includes("x√©t nghi·ªám") || description.includes("k·∫øt qu·∫£") || description.includes("test") || description.includes("lab")) {
              // Medical results could be PDF or image
              if (fileSize > 1000000) { // > 1MB likely scan/image
                fileType = "medical_scan";
                downloadName = `medical_result_${Date.now()}.pdf`;
                mimeType = "application/pdf";
              } else {
                fileType = "medical_report";
                downloadName = `medical_report_${Date.now()}.txt`;
                mimeType = "text/plain";
              }
            } else if (description.includes("ct") || description.includes("mri") || description.includes("x-ray") || description.includes("ch·ª•p")) {
              fileType = "medical_image";
              downloadName = `medical_scan_${Date.now()}.jpg`;
              mimeType = "image/jpeg";
            } else if (description.includes("ghi ch√∫") || description.includes("note")) {
              fileType = "note";
              downloadName = `note_${Date.now()}.txt`;
              mimeType = "text/plain";
            } else {
              // Default based on size
              if (fileSize > 5000000) { // > 5MB
                fileType = "large_document";
                downloadName = `large_file_${Date.now()}.pdf`;
                mimeType = "application/pdf";
              } else if (fileSize > 100000) { // > 100KB
                fileType = "document";
                downloadName = `document_${Date.now()}.pdf`;
                mimeType = "application/pdf";
              } else {
                fileType = "small_file";
                downloadName = `file_${Date.now()}.bin`;
                mimeType = "application/octet-stream";
              }
            }
            
            // Create blob with proper MIME type after detection
            const blob = new Blob([decryptedBuffer], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            // Store these globally for the button handlers
            window.currentDecryptedBlob = blob;
            window.currentDecryptedUrl = url;
            window.currentFileType = fileType;
            window.currentDownloadName = downloadName;
            
            decryptedContent.innerHTML = `
              <h5>üéâ File ƒë√£ gi·∫£i m√£ th√†nh c√¥ng!</h5>
              <div style="background-color: white; padding: 15px; border-radius: 5px; border: 1px solid #c3e6cb;">
                <div style="margin-bottom: 15px;">
                  <strong>üìÅ Lo·∫°i file:</strong> ${fileType.toUpperCase().replace(/_/g, ' ')}<br>
                  <strong>üìè K√≠ch th∆∞·ªõc:</strong> ${fileSizeFormatted}<br>
                  <strong>üìÑ M√¥ t·∫£ g·ªëc:</strong> ${currentRecord.description}<br>
                  <strong>üè∑Ô∏è Data Type:</strong> ${currentRecord.data_type}<br>
                  <strong>üîó MIME Type:</strong> ${mimeType}<br>
                  <strong>üßÆ Entropy:</strong> ${entropy.toFixed(3)} (${entropy > 0.8 ? 'High - Real encryption' : 'Low - Test data'})<br>
                  <strong>üìÖ T·∫°o l√∫c:</strong> ${new Date(currentRecord.created_at).toLocaleString('vi-VN')}
                </div>
                
                <div style="margin-bottom: 15px;">
                  <button onclick="downloadCurrentFile()" 
                          style="background-color: #28a745; padding: 10px 20px; color: white; border: none; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                    üíæ T·∫£i v·ªÅ file ƒë√£ gi·∫£i m√£
                  </button>
                  
                  <button onclick="previewCurrentFile()" 
                          style="background-color: #17a2b8; padding: 10px 20px; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    üëÅÔ∏è Xem tr∆∞·ªõc (n·∫øu c√≥ th·ªÉ)
                  </button>
                </div>
                
                <div id="filePreview" style="margin-top: 15px;"></div>
              </div>
            `;
          }
          decryptedResult.style.display = "block";

          displayStatus("Gi·∫£i m√£ th√†nh c√¥ng!", "success");

        } catch (error) {
          console.error("Decryption error:", error);
          displayStatus(`L·ªói gi·∫£i m√£: ${error.message}`, "error");
        } finally {
          decryptButton.disabled = false;
        }
      }

      // --- File Handling Functions ---
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      function downloadCurrentFile() {
        if (!window.currentDecryptedBlob || !window.currentDownloadName) {
          alert('Kh√¥ng c√≥ file ƒë·ªÉ t·∫£i xu·ªëng');
          return;
        }
        
        const link = document.createElement('a');
        link.href = window.currentDecryptedUrl;
        link.download = window.currentDownloadName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }

      function previewCurrentFile() {
        if (!window.currentDecryptedBlob || !window.currentDecryptedUrl) {
          alert('Kh√¥ng c√≥ file ƒë·ªÉ xem tr∆∞·ªõc');
          return;
        }
        
        const previewDiv = document.getElementById('filePreview');
        const fileType = window.currentFileType;
        
        // Clear previous preview
        previewDiv.innerHTML = '';
        
        try {
          if (fileType.includes('image') || fileType.includes('medical_image')) {
            // Try to display as image
            previewDiv.innerHTML = `
              <h6>üñºÔ∏è Xem tr∆∞·ªõc h√¨nh ·∫£nh:</h6>
              <img src="${window.currentDecryptedUrl}" 
                   style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 5px;" 
                   onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
              <div style="display: none; padding: 10px; background-color: #f8d7da; color: #842029; border-radius: 5px;">
                ‚ùå Kh√¥ng th·ªÉ hi·ªÉn th·ªã h√¨nh ·∫£nh. Vui l√≤ng t·∫£i xu·ªëng ƒë·ªÉ xem.
              </div>
            `;
          } else if (fileType.includes('pdf') || fileType.includes('document')) {
            // Open PDF in new tab/window
            const newWindow = window.open(window.currentDecryptedUrl, '_blank');
            if (!newWindow) {
              previewDiv.innerHTML = `
                <div style="padding: 10px; background-color: #fff3cd; color: #664d03; border-radius: 5px;">
                  ‚ö†Ô∏è Tr√¨nh duy·ªát ch·∫∑n popup. Vui l√≤ng b·∫•m v√†o link sau ƒë·ªÉ xem file:
                  <br><br>
                  <a href="${window.currentDecryptedUrl}" target="_blank" 
                     style="background-color: #17a2b8; color: white; padding: 8px 16px; text-decoration: none; border-radius: 4px; display: inline-block;">
                    üìÑ M·ªü PDF trong tab m·ªõi
                  </a>
                </div>
              `;
            } else {
              previewDiv.innerHTML = `
                <div style="padding: 10px; background-color: #d1e7dd; color: #0f5132; border-radius: 5px;">
                  ‚úÖ PDF ƒë√£ m·ªü trong tab m·ªõi
                </div>
              `;
            }
          } else {
            // For other file types, provide download link
            previewDiv.innerHTML = `
              <div style="padding: 10px; background-color: #cff4fc; color: #055160; border-radius: 5px;">
                ‚ÑπÔ∏è Lo·∫°i file n√†y kh√¥ng th·ªÉ xem tr∆∞·ªõc tr·ª±c ti·∫øp. Vui l√≤ng t·∫£i xu·ªëng ƒë·ªÉ m·ªü b·∫±ng ·ª©ng d·ª•ng ph√π h·ª£p.
                <br><br>
                <button onclick="downloadCurrentFile()" 
                        style="background-color: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
                  üíæ T·∫£i xu·ªëng ngay
                </button>
              </div>
            `;
          }
        } catch (error) {
          console.error('Preview error:', error);
          previewDiv.innerHTML = `
            <div style="padding: 10px; background-color: #f8d7da; color: #842029; border-radius: 5px;">
              ‚ùå L·ªói khi xem tr∆∞·ªõc: ${error.message}
              <br><br>
              <button onclick="downloadCurrentFile()" 
                      style="background-color: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
                üíæ T·∫£i xu·ªëng thay th·∫ø
              </button>
            </div>
          `;
        }
      }

      // --- Initial Page Load ---
      document.addEventListener("DOMContentLoaded", async function () {

        
        const recordId = getRecordIdFromURL();
        if (!recordId) {
          displayStatus("ID b·∫£n ghi kh√¥ng h·ª£p l·ªá.", "error");
          recordInfo.innerHTML = `
            <div style="color: #842029; text-align: center;">
              <h4>‚ùå L·ªói URL</h4>
              <p>Kh√¥ng t√¨m th·∫•y ID b·∫£n ghi trong URL.</p>
              <button onclick="goHome()">V·ªÅ Trang Ch·ªß</button>
            </div>
          `;
          return;
        }

        // Load record first
        await loadRecordById(recordId);
        
        // Check if currentRecord is loaded successfully
        // If not (e.g., due to 403 error), don't initialize Pyodide
        if (!currentRecord) {
          console.log("Record not loaded, skipping Pyodide initialization");
          return;
        }
        
        // Initialize Pyodide - disable file input until complete
        privateKeyFileInput.disabled = true;
        displayStatus("ƒêang kh·ªüi t·∫°o th∆∞ vi·ªán gi·∫£i m√£...", "info");
        await initializePyodide();
      });
    </script>
  </body>
</html> 