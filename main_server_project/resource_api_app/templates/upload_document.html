<!DOCTYPE html>

<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nh·∫≠p v√† M√£ H√≥a D·ªØ Li·ªáu Y T·∫ø</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.7/full/pyodide.js"></script>
    <style>
        /* (S·ª≠ d·ª•ng CSS t∆∞∆°ng t·ª± nh∆∞ trang upload tr∆∞·ªõc ƒë√≥, c√≥ th·ªÉ t√πy ch·ªânh) */
      body {
        font-family: "Segoe UI", sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #eef1f5;
        color: #333;
        line-height: 1.6;
      }
      .container {
        max-width: 800px;
        margin: 30px auto;
        background-color: #fff;
        padding: 20px 30px 30px 30px;
        border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }
      h2 {
        text-align: center;
        color: #2c3e50;
        margin-bottom: 30px;
        font-weight: 600;
      }
      .form-section {
        margin-bottom: 25px;
        padding-bottom: 25px;
        border-bottom: 1px solid #e0e0e0;
      }
      .form-section:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
      }
      .form-group {
        margin-bottom: 18px;
      }
      .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #495057;
        font-size: 0.95em;
      }
      .form-group input[type="text"],
      .form-group input[type="file"],
      .form-group textarea,
      .form-group select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid #ced4da;
        border-radius: 5px;
        box-sizing: border-box;
        font-size: 1em;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
      .form-group input[type="text"]:focus,
      .form-group input[type="file"]:focus,
      .form-group textarea:focus,
      .form-group select:focus {
        border-color: #80bdff;
        outline: 0;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }
      .form-group textarea {
        resize: vertical;
        min-height: 150px;
      } /* TƒÉng chi·ªÅu cao cho n·ªôi dung ch√≠nh */
      .policy-builder legend {
        font-weight: 700;
        font-size: 1.15em;
        margin-bottom: 15px;
        color: #34495e;
        padding-bottom: 5px;
        border-bottom: 1px solid #dee2e6;
      }
      .policy-category {
        margin-bottom: 25px;
        padding: 15px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        background-color: #fafafa;
      }
      .policy-category > label {
        font-weight: 600;
        color: #2c3e50;
        margin-bottom: 12px;
        display: block;
        font-size: 1.05em;
      }
      .policy-option {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        padding: 5px 0;
      }
      .policy-option input[type="checkbox"] {
        margin-right: 10px;
        width: auto;
        transform: scale(1.1);
      }
      .policy-option label {
        font-weight: normal;
        color: #495057;
        margin-bottom: 0;
        cursor: pointer;
        padding: 2px 5px;
        border-radius: 3px;
        transition: background-color 0.2s;
      }
      .policy-option label:hover {
        background-color: #e9ecef;
      }
      #generatedPolicyPreviewContainer {
        margin-top: 20px;
        padding: 15px;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        background-color: #f8f9fa;
      }
      #generatedPolicyPreviewContainer strong {
        font-weight: 600;
        color: #34495e;
        display: block;
        margin-bottom: 10px;
      }
        #generatedPolicyPreview {
        margin: 0;
        padding: 12px;
        background-color: #ffffff;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-family: "Courier New", Courier, monospace;
        color: #495057;
        min-height: 60px;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-size: 0.85em;
        line-height: 1.4;
        overflow-x: auto;
        }
        button {
        display: inline-block;
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 500;
        transition: background-color 0.3s ease;
        margin-right: 10px;
        margin-top: 10px;
        }
      button:hover {
        background-color: #0056b3;
      }
      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      .message-area {
        margin-top: 20px;
        padding: 12px;
        border-radius: 5px;
        text-align: center;
        font-size: 0.95em;
      }
      .success {
        background-color: #d1e7dd;
        color: #0f5132;
        border: 1px solid #badbcc;
      }
      .error {
        background-color: #f8d7da;
        color: #842029;
        border: 1px solid #f5c2c7;
      }
      .info {
        background-color: #cff4fc;
        color: #055160;
        border-color: #b6effb;
      }
      .warning {
        background-color: #fff3cd;
        color: #664d03;
        border: 1px solid #ffecb5;
      }
      .file-upload-status {
        font-size: 0.9em;
        margin-left: 10px;
        color: #28a745;
      }
    </style>
</head>
  <body>
    <div class="container">
      <!-- User Info Header -->
      <div class="user-header" id="userHeader" style="display: none; background-color: #f8f9fa; padding: 10px 15px; border-radius: 5px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
        <div>
          <span style="font-weight: 600; color: #2c3e50;">üë§ ƒê√£ ƒëƒÉng nh·∫≠p: </span>
          <span id="currentUsername" style="color: #007bff;">Loading...</span>
        </div>
        <div>
          <a href="/decrypt/" style="background-color: #28a745; color: white; padding: 5px 10px; border-radius: 3px; text-decoration: none; margin-right: 10px;">üìñ Xem D·ªØ Li·ªáu</a>
          <button onclick="logout()" style="background-color: #dc3545; color: white; padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer;">üö™ ƒêƒÉng Xu·∫•t</button>
        </div>
      </div>
      
      <h2>Nh·∫≠p v√† M√£ H√≥a D·ªØ Li·ªáu Y T·∫ø</h2>
        <form id="ehrDataForm">
            <div class="form-section">
                <h3>Th√¥ng Tin C∆° B·∫£n (Kh√¥ng m√£ h√≥a)</h3>
                <div class="form-group">
                    <label for="patientIdInput">M√£ B·ªánh Nh√¢n:</label>
            <input type="text" id="patientIdInput" name="patient_id" required />
                </div>
                <div class="form-group">
                    <label for="documentDescriptionInput">M√¥ T·∫£ Chung:</label>
            <input
              type="text"
              id="documentDescriptionInput"
              name="description"
              required
            />
                </div>
                <div class="form-group">
                    <label for="dataTypeSelect">Lo·∫°i D·ªØ Li·ªáu:</label>
                    <select id="dataTypeSelect" name="data_type" required>
                        <option value="">-- Vui l√≤ng ch·ªçn --</option>
                        <option value="CONSULTATION_NOTE">Ghi ch√∫ kh√°m b·ªánh</option>
                        <option value="LAB_RESULT_SUMMARY">T√≥m t·∫Øt KQ X√©t nghi·ªám</option>
                        <option value="TREATMENT_PLAN">K·∫ø ho·∫°ch ƒëi·ªÅu tr·ªã</option>
              <option value="OTHER_SENSITIVE_NOTE">
                Ghi ch√∫ nh·∫°y c·∫£m kh√°c
              </option>
                    </select>
                </div>
            </div>

            <div class="form-section">
                <h3>N·ªôi Dung Chi Ti·∫øt (S·∫Ω ƒë∆∞·ª£c m√£ h√≥a)</h3>
                
                <!-- Content Input Mode Selection -->
                <div class="form-group">
                    <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                        Ch·ªçn m·ªôt trong hai c√°ch nh·∫≠p n·ªôi dung:
                    </p>
                    <div style="margin-bottom: 15px;">
                        <label style="display: inline-flex; align-items: center; margin-right: 20px;">
                            <input type="radio" name="contentInputMode" value="text" id="textModeRadio" checked style="margin-right: 8px;">
                            <span>Nh·∫≠p vƒÉn b·∫£n tr·ª±c ti·∫øp</span>
                        </label>
                        <label style="display: inline-flex; align-items: center;">
                            <input type="radio" name="contentInputMode" value="file" id="fileModeRadio" style="margin-right: 8px;">
                            <span>T·∫£i l√™n file</span>
                        </label>
                    </div>
                </div>

                <!-- Text Input Mode -->
                <div id="textInputSection" class="form-group">
                    <label for="sensitiveContentInput">N·ªôi dung chi ti·∫øt:</label>
                    <textarea
                        id="sensitiveContentInput"
                        name="sensitive_content"
                        rows="10"
                        placeholder="Nh·∫≠p n·ªôi dung c·∫ßn m√£ h√≥a..."
                    ></textarea>
                </div>

                <!-- File Input Mode -->
                <div id="fileInputSection" class="form-group" style="display: none;">
                    <label for="contentFileInput">Ch·ªçn file ƒë·ªÉ m√£ h√≥a:</label>
                    <input 
                        type="file" 
                        id="contentFileInput"
                        accept=".txt,.doc,.docx,.pdf,.jpg,.jpeg,.png,.gif,.bmp,.webp,.xlsx,.pptx,.csv"
                        style="margin-bottom: 10px;"
                    />
                    <div style="font-size: 0.85em; color: #666; margin-bottom: 10px;">
                        <strong>H·ªó tr·ª£:</strong> Text (.txt), Documents (.doc, .docx, .pdf), Images (.jpg, .png, .gif), Excel (.xlsx), PowerPoint (.pptx)<br>
                        <strong>K√≠ch th∆∞·ªõc t·ªëi ƒëa:</strong> 10MB (5MB cho ·∫£nh)
                    </div>
                    <div id="fileStatus" style="font-size: 0.9em; margin-top: 5px;"></div>
                    
                    <!-- File Preview -->
                    <div id="filePreviewContainer" style="display: none; margin-top: 15px; padding: 15px; background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 5px;">
                        <h5 style="margin-top: 0; color: #495057;">Preview:</h5>
                        <div id="textFilePreview" style="display: none; max-height: 200px; overflow-y: auto; white-space: pre-wrap; background: white; padding: 10px; border-radius: 3px; border: 1px solid #ced4da;"></div>
                        <img id="imageFilePreview" style="display: none; max-width: 100%; max-height: 300px; border-radius: 5px;" />
                        <div id="binaryFilePreview" style="display: none; font-family: monospace; font-size: 0.9em; color: #666;"></div>
                    </div>
                </div>
            </div>

            <div class="form-section">
                <fieldset class="policy-builder">
                    <legend>ƒê·ªãnh Nghƒ©a Ch√≠nh S√°ch Truy C·∫≠p (CP-ABE)</legend>
            <p style="font-size: 0.9em; color: #777; margin-bottom: 15px">
              Ch·ªçn c√°c thu·ªôc t√≠nh ƒë·ªÉ ƒë·ªãnh nghƒ©a ai c√≥ th·ªÉ gi·∫£i m√£ n·ªôi dung chi
              ti·∫øt ·ªü tr√™n.
                    </p>
                    <div id="policyAttributeGroupsContainer">
                        <!-- JavaScript s·∫Ω t·ª± ƒë·ªông ƒëi·ªÅn c√°c nh√≥m thu·ªôc t√≠nh -->
                    </div>
                    <div class="policy-category">
              <label for="customAttributesInput"
                >Thu·ªôc t√≠nh b·ªï sung (VD:
                <code>KEY:VALUE,OTHER:VAL</code>):</label
              >
              <input
                type="text"
                id="customAttributesInput"
                name="custom_attributes"
                placeholder="PROJECT_ID:XYZ, URGENCY:HIGH"
              />
                    </div>
                    <div id="generatedPolicyPreviewContainer">
                        <strong>Ch√≠nh s√°ch s·∫Ω ƒë∆∞·ª£c t·∫°o:</strong>
              <pre id="generatedPolicyPreview">
(Ch∆∞a c√≥ ƒëi·ªÅu ki·ªán n√†o ƒë∆∞·ª£c ch·ªçn)</pre
              >
                    </div>
                </fieldset>
            </div>

            <div class="form-section">
                <h3>Kh√≥a C√¥ng Khai CP-ABE</h3>
                <div class="form-group">
            <label for="publicKeyFile"
              >T·∫£i l√™n file Public Key CP-ABE (<code>.bin</code> ho·∫∑c <code>.json</code>):</label
            >
            <input type="file" id="publicKeyFile" accept=".bin,.json" />
                    <span id="publicKeyStatus" class="file-upload-status"></span>
                </div>
            </div>

        <button type="submit" id="submitButton">M√£ H√≥a v√† G·ª≠i D·ªØ Li·ªáu</button>
        </form>
      <div
        id="submissionStatus"
        class="message-area"
        style="display: none"
      ></div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-content">
        <div class="spinner"></div>
        <h3>ƒêang kh·ªüi t·∫°o h·ªá th·ªëng m√£ h√≥a...</h3>
        <p id="loadingStatus">ƒêang t·∫£i Pyodide v√† th∆∞ vi·ªán Charm-Crypto</p>
      </div>
    </div>

    <style>
      .loading-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 9999;
        color: white;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      .loading-overlay.show {
        display: flex;
      }
      .loading-content {
        text-align: center;
      }
      .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>

    <script>
        // --- DOM Elements ---
      const ehrDataForm = document.getElementById("ehrDataForm");
      const policyPreviewElement = document.getElementById(
        "generatedPolicyPreview"
      );
      const customAttributesElement = document.getElementById(
        "customAttributesInput"
      );
      const statusMessageElement = document.getElementById("submissionStatus");
      const submitButton = document.getElementById("submitButton");
      const policyAttributeGroupsContainer = document.getElementById(
        "policyAttributeGroupsContainer"
      );
      const publicKeyFileInput = document.getElementById("publicKeyFile");
      const publicKeyStatus = document.getElementById("publicKeyStatus");
      const sensitiveContentInput = document.getElementById(
        "sensitiveContentInput"
      );
      
      // File Upload Elements
      const textModeRadio = document.getElementById("textModeRadio");
      const fileModeRadio = document.getElementById("fileModeRadio");
      const textInputSection = document.getElementById("textInputSection");
      const fileInputSection = document.getElementById("fileInputSection");
      const contentFileInput = document.getElementById("contentFileInput");
      const fileStatus = document.getElementById("fileStatus");
      const filePreviewContainer = document.getElementById("filePreviewContainer");
      const textFilePreview = document.getElementById("textFilePreview");
      const imageFilePreview = document.getElementById("imageFilePreview");
      const binaryFilePreview = document.getElementById("binaryFilePreview");

        // --- Global State ---
        let pyodide = null;
      let abePublicKeyObject = null;
      let fileContentForEncryption = null; // Stores file content as base64 or text
      let currentInputMode = "text"; // "text" or "file"
      
      // File size limits
      const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
      const MAX_IMAGE_SIZE = 5 * 1024 * 1024; // 5MB

      // S·ª≠a URL API ƒë·ªÉ match v·ªõi URLs ƒë√£ t·∫°o
      const UPLOAD_API_URL = "/api/ehr/upload/";

      // --- Thu·ªôc t√≠nh v√† Categories v·ªõi ID mapping ---
      const attributeIdMapping = {
        "ROLE:DOCTOR": 1,
        "ROLE:NURSE": 2,
        "ROLE:SPECIALIST": 3,
        "ROLE:PHARMACIST": 4,
        "ROLE:LAB_TECHNICIAN": 5,
        // "ROLE:ADMINISTRATOR": 6, // Kh√¥ng hi·ªÉn th·ªã role admin
        "ROLE:RECEPTIONIST": 7,
        "ROLE:PATIENT": 8,
        "ROLE:RESEARCHER": 9,
        "ROLE:INSURANCE_STAFF": 10,
        "DEPARTMENT:CARDIOLOGY": 11,
        "DEPARTMENT:ONCOLOGY": 12,
        "DEPARTMENT:PEDIATRICS": 13,
        "DEPARTMENT:SURGERY": 14,
        "DEPARTMENT:RADIOLOGY": 15,
        "DEPARTMENT:EMERGENCY": 16,
        "DEPARTMENT:INTERNAL_MEDICINE": 17,
        "DEPARTMENT:LABORATORY": 18,
        "DEPARTMENT:PHARMACY": 19,
        "INFO:MEDICAL_HISTORY": 20,
        "INFO:LAB_RESULTS": 21,
        "INFO:PRESCRIPTIONS": 22,
        "INFO:IMAGING_REPORTS": 23,
        "INFO:BILLING": 24,
        "INFO:DEMOGRAPHICS": 25,
        "ACTION:VIEW": 26,
        "ACTION:EDIT": 27,
        "ACTION:PRESCRIBE": 28,
        "ACTION:ORDER_TEST": 29,
        "CONTEXT:EMERGENCY_ACCESS": 30,
        "CONTEXT:RESEARCH_ANONYMIZED": 31,
        "PATIENT_RELATIONSHIP:TREATING_PHYSICIAN": 32,
        "PATIENT_RELATIONSHIP:CONSULTING_PHYSICIAN": 33,
        "ACCESS_LEVEL:SENSITIVE": 34,
        "LOCATION:HOSPITAL_A": 35,
        "LOCATION:CLINIC_B": 36,
        "TIME_CONSTRAINT:ON_DUTY": 37,
      };

      const availableAttributes = Object.keys(attributeIdMapping);

      const attributeCategoriesConfig = {
        ROLE: "Vai tr√≤ ng∆∞·ªùi truy c·∫≠p",
        DEPARTMENT: "Chuy√™n khoa/Ph√≤ng ban ng∆∞·ªùi truy c·∫≠p",
        INFO: "Quy·ªÅn truy c·∫≠p lo·∫°i th√¥ng tin",
        ACTION: "H√†nh ƒë·ªông ƒë∆∞·ª£c ph√©p th·ª±c hi·ªán",
        CONTEXT: "Ng·ªØ c·∫£nh truy c·∫≠p ƒë·∫∑c bi·ªát",
        PATIENT_RELATIONSHIP: "M·ªëi quan h·ªá v·ªõi b·ªánh nh√¢n",
        ACCESS_LEVEL: "M·ª©c ƒë·ªô truy c·∫≠p c·ªßa ng∆∞·ªùi xem",
        LOCATION: "ƒê·ªãa ƒëi·ªÉm l√†m vi·ªác c·ªßa ng∆∞·ªùi xem",
        TIME_CONSTRAINT: "ƒêi·ªÅu ki·ªán th·ªùi gian l√†m vi·ªác",
        };

        // --- Helper Functions ---
      function displayStatus(message, type = "info") {
            statusMessageElement.textContent = message;
            statusMessageElement.className = `message-area ${type}`;
        statusMessageElement.style.display = "block";
        }

      // --- Input Mode Switching ---
      textModeRadio.addEventListener("change", function() {
        if (this.checked) {
          currentInputMode = "text";
          textInputSection.style.display = "block";
          fileInputSection.style.display = "none";
          fileContentForEncryption = null;
          fileStatus.textContent = "";
          hideFilePreview();
        }
      });

      fileModeRadio.addEventListener("change", function() {
        if (this.checked) {
          currentInputMode = "file";
          textInputSection.style.display = "none";
          fileInputSection.style.display = "block";
          sensitiveContentInput.value = "";
        }
      });

      function hideFilePreview() {
        filePreviewContainer.style.display = "none";
        textFilePreview.style.display = "none";
        imageFilePreview.style.display = "none";
        binaryFilePreview.style.display = "none";
      }

      function showFilePreview(type) {
        filePreviewContainer.style.display = "block";
        hideFilePreview();
        
        if (type === "text") {
          textFilePreview.style.display = "block";
        } else if (type === "image") {
          imageFilePreview.style.display = "block";
        } else if (type === "binary") {
          binaryFilePreview.style.display = "block";
        }
      }

      // --- File Upload Handler ---
      contentFileInput.addEventListener("change", function(event) {
        const file = event.target.files[0];
        
        if (!file) {
          fileContentForEncryption = null;
          fileStatus.textContent = "";
          hideFilePreview();
          return;
        }

        // File size validation
        const isImage = file.type.startsWith('image/');
        const maxSize = isImage ? MAX_IMAGE_SIZE : MAX_FILE_SIZE;
        
        if (file.size > maxSize) {
          const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(1);
          const fileSizeMB = (file.size / (1024 * 1024)).toFixed(1);
          
          fileStatus.innerHTML = `<span style="color: red;">‚ùå File qu√° l·ªõn: ${fileSizeMB}MB. T·ªëi ƒëa: ${maxSizeMB}MB</span>`;
          displayStatus(`File "${file.name}" qu√° l·ªõn. Vui l√≤ng ch·ªçn file nh·ªè h∆°n ${maxSizeMB}MB.`, "error");
          
          // Clear the input
          contentFileInput.value = "";
          fileContentForEncryption = null;
          hideFilePreview();
          return;
        }

        // Show loading status
        fileStatus.innerHTML = `<span style="color: orange;">üìÅ ƒêang x·ª≠ l√Ω: ${file.name} (${(file.size / 1024).toFixed(1)}KB)...</span>`;

        // Process file based on type
        processFile(file);
      });

      function processFile(file) {
        const fileType = file.type;
        const fileName = file.name.toLowerCase();

        if (fileType.startsWith('image/')) {
          processImageFile(file);
        } else if (fileType === 'text/plain' || fileName.endsWith('.txt')) {
          processTextFile(file);
        } else {
          processBinaryFile(file);
        }
      }

      function processTextFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const textContent = e.target.result;
          fileContentForEncryption = textContent; // Store as text for text files
          
          // Show preview
          const preview = textContent.length > 1000 
            ? textContent.substring(0, 1000) + "\n\n... (hi·ªÉn th·ªã 1000 k√Ω t·ª± ƒë·∫ßu)"
            : textContent;
          textFilePreview.textContent = preview;
          showFilePreview('text');
          
          fileStatus.innerHTML = `<span style="color: green;">‚úÖ Text file s·∫µn s√†ng: ${file.name} (${textContent.length} k√Ω t·ª±)</span>`;
          displayStatus(`File text "${file.name}" ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng.`, "success");
        };
        reader.onerror = function() {
          fileStatus.innerHTML = `<span style="color: red;">‚ùå L·ªói ƒë·ªçc file text</span>`;
        };
        reader.readAsText(file, 'UTF-8');
      }

      function processImageFile(file) {
        // Show image preview
        const previewReader = new FileReader();
        previewReader.onload = function(e) {
          imageFilePreview.src = e.target.result;
          showFilePreview('image');
        };
        previewReader.readAsDataURL(file);

        // Read for encryption (binary)
        const binaryReader = new FileReader();
        binaryReader.onload = function(e) {
          fileContentForEncryption = arrayBufferToBase64(e.target.result);
          fileStatus.innerHTML = `<span style="color: green;">‚úÖ ·∫¢nh s·∫µn s√†ng: ${file.name}</span>`;
          displayStatus(`·∫¢nh "${file.name}" ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng.`, "success");
        };
        binaryReader.onerror = function() {
          fileStatus.innerHTML = `<span style="color: red;">‚ùå L·ªói ƒë·ªçc file ·∫£nh</span>`;
        };
        binaryReader.readAsArrayBuffer(file);
      }

      function processBinaryFile(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          fileContentForEncryption = arrayBufferToBase64(e.target.result);
          
          // Show file info
          const fileSizeKB = (file.size / 1024).toFixed(1);
          binaryFilePreview.innerHTML = `
            <strong>üìÑ ${file.name}</strong><br>
            Lo·∫°i: ${file.type || 'Unknown'}<br>
            K√≠ch th∆∞·ªõc: ${fileSizeKB}KB<br>
            <em>S·∫Ω ƒë∆∞·ª£c m√£ h√≥a d∆∞·ªõi d·∫°ng binary data</em>
          `;
          showFilePreview('binary');
          
          fileStatus.innerHTML = `<span style="color: green;">‚úÖ File s·∫µn s√†ng: ${file.name}</span>`;
          displayStatus(`File "${file.name}" ƒë√£ ƒë∆∞·ª£c t·∫£i th√†nh c√¥ng.`, "success");
        };
        reader.onerror = function() {
          fileStatus.innerHTML = `<span style="color: red;">‚ùå L·ªói ƒë·ªçc file</span>`;
        };
        reader.readAsArrayBuffer(file);
      }

      // --- Content Validation Function ---
      function getContentForEncryption() {
        if (currentInputMode === "text") {
          const textContent = sensitiveContentInput.value.trim();
          if (!textContent) {
            throw new Error("Vui l√≤ng nh·∫≠p n·ªôi dung vƒÉn b·∫£n ho·∫∑c ch·ªçn file ƒë·ªÉ upload.");
          }
          return textContent;
        } else if (currentInputMode === "file") {
          if (!fileContentForEncryption) {
            throw new Error("Vui l√≤ng ch·ªçn file ƒë·ªÉ upload.");
          }
          return fileContentForEncryption;
        }
        throw new Error("Vui l√≤ng ch·ªçn ph∆∞∆°ng th·ª©c nh·∫≠p n·ªôi dung.");
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            // Use more reliable method for binary data
            let binaryString = "";
            for (let i = 0; i < bytes.byteLength; i++) {
                binaryString += String.fromCharCode(bytes[i]);
            }
            return btoa(binaryString);
        }

      // --- Policy UI Logic ---
      function generatePolicyUI() {
        const categories = {};

        // Nh√≥m attributes theo category
        availableAttributes.forEach((attr) => {
          const [category, value] = attr.split(":");
          if (!categories[category]) {
            categories[category] = [];
          }
          categories[category].push(attr);
        });

        // T·∫°o UI cho t·ª´ng category v·ªõi radio buttons ho·∫∑c select
        Object.keys(categories).forEach((categoryKey) => {
          const categoryDiv = document.createElement("div");
          categoryDiv.className = "policy-category";

          const categoryLabel = document.createElement("label");
          categoryLabel.textContent = `${
            attributeCategoriesConfig[categoryKey] || categoryKey
          } (ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu):`;
          categoryDiv.appendChild(categoryLabel);

          // T·∫°o container cho c√°c options
          const optionsContainer = document.createElement("div");
          optionsContainer.style.marginLeft = "20px";
          optionsContainer.style.marginTop = "8px";

          categories[categoryKey].forEach((attr) => {
            const optionDiv = document.createElement("div");
            optionDiv.className = "policy-option";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = `attr_${attr.replace(/[:\s]/g, "_")}`;
            checkbox.value = attr;
            checkbox.name = `category_${categoryKey}`; // Group by category
            checkbox.addEventListener("change", buildAndDisplayPolicyString);

            const label = document.createElement("label");
            label.htmlFor = checkbox.id;
            label.textContent = attr.split(":")[1]; // Ch·ªâ hi·ªÉn th·ªã ph·∫ßn sau d·∫•u :
            label.style.marginLeft = "5px";

            optionDiv.appendChild(checkbox);
            optionDiv.appendChild(label);
            optionsContainer.appendChild(optionDiv);
          });

          categoryDiv.appendChild(optionsContainer);
          policyAttributeGroupsContainer.appendChild(categoryDiv);
        });
      }

      function buildAndDisplayPolicyString() {
        // Nh√≥m c√°c attributes ƒë√£ ch·ªçn theo category
        const selectedByCategory = {};

        // L·∫•y c√°c checkbox ƒë√£ ch·ªçn v√† nh√≥m theo category
        const checkboxes = policyAttributeGroupsContainer.querySelectorAll(
          'input[type="checkbox"]:checked'
        );
        checkboxes.forEach((cb) => {
          const attr = cb.value;
          const category = attr.split(":")[0];
          if (!selectedByCategory[category]) {
            selectedByCategory[category] = [];
          }
          selectedByCategory[category].push(attr);
        });

        // Parse custom attributes
        const customInput = customAttributesElement.value.trim();
        if (customInput) {
          const customAttrs = customInput
            .split(",")
            .map((attr) => attr.trim())
            .filter((attr) => attr);
          if (!selectedByCategory["CUSTOM"]) {
            selectedByCategory["CUSTOM"] = [];
          }
          selectedByCategory["CUSTOM"].push(...customAttrs);
        }

        // T·∫°o policy string v·ªõi logic OR trong category, AND gi·ªØa c√°c category
        const categoryPolicies = [];
        const categoryPoliciesReadable = [];

        Object.keys(selectedByCategory).forEach((category) => {
          const attrs = selectedByCategory[category];
          if (attrs.length > 0) {
            // Convert attributes to IDs
            const convertedIds = attrs.map((attr) => {
              const id = attributeIdMapping[attr];
              if (id !== undefined) {
                return id;
              } else {
                // Custom attribute hash
                let hash = 0;
                for (let i = 0; i < attr.length; i++) {
                  const char = attr.charCodeAt(i);
                  hash = (hash << 5) - hash + char;
                  hash = hash & hash;
                }
                return Math.abs(hash % 1000) + 1000;
              }
            });

            // T·∫°o OR group cho category n√†y
            if (attrs.length === 1) {
              categoryPolicies.push(convertedIds[0]);
              categoryPoliciesReadable.push(attrs[0]);
            } else {
              categoryPolicies.push(`(${convertedIds.join(" or ")})`);
              categoryPoliciesReadable.push(`(${attrs.join(" or ")})`);
            }
          }
        });

        // Combine categories with AND
        let policyString = "";
        let readablePolicy = "";

        if (categoryPolicies.length > 0) {
          policyString = categoryPolicies.join(" and ");
          readablePolicy = categoryPoliciesReadable.join(" and ");

          // Format policy display properly
          policyPreviewElement.innerHTML = `<strong>Policy (readable):</strong>\n${readablePolicy}\n\n<strong>Policy (IDs):</strong>\n${policyString}`;
        } else {
          policyString = "";
          policyPreviewElement.textContent =
            "(Ch∆∞a c√≥ ƒëi·ªÅu ki·ªán n√†o ƒë∆∞·ª£c ch·ªçn)";
        }

        return categoryPolicies.length > 0 ? policyString : null;
      }

        // --- Pyodide and CP-ABE Initialization ---
        async function initializePyodide() {
        // Show loading overlay
        const loadingOverlay = document.getElementById("loadingOverlay");
        const loadingStatus = document.getElementById("loadingStatus");
        loadingOverlay.classList.add("show");
        
        try {
          loadingStatus.textContent = "ƒêang t·∫£i Pyodide...";
          
          // Load Pyodide (·∫©n stdout/stderr logs)
                pyodide = await loadPyodide({
            stdout: () => {}, // ·∫®n logs
            stderr: () => {}, // ·∫®n error logs
                });

          loadingStatus.textContent = "ƒêang t·∫£i micropip...";
                await pyodide.loadPackage("micropip");
                const micropip = pyodide.pyimport("micropip");

          loadingStatus.textContent = "ƒêang c√†i ƒë·∫∑t Charm-Crypto...";
                // URL ƒë·∫øn wheel c·ªßa Charm-Crypto ƒë√£ ƒë∆∞·ª£c build cho Pyodide
          const charmWheelURL =
            "https://quackusarle.github.io/charm_crypto_wheel_for_pyodide/charm_crypto-0.50-cp312-cp312-pyodide_2024_0_wasm32.whl";
                await micropip.install(charmWheelURL);

          loadingStatus.textContent = "ƒêang kh·ªüi t·∫°o h·ªá th·ªëng CP-ABE...";
          // Initialize CP-ABE system nh∆∞ trong medical_upload.js
          await pyodide.runPythonAsync(`

from charm.toolbox.pairinggroup import PairingGroup
from charm.schemes.abenc.waters11 import Waters11

group = PairingGroup('SS512')
waters_abe = Waters11(group, uni_size=100)

globals()["_waters11_abe_scheme"] = waters_abe
globals()["_waters11_group"] = group

`);

          // Test initialization - DEBUG LINE 870
          const testResult = await pyodide.runPythonAsync(`
result = "SUCCESS"
try:
    _waters11_abe_scheme
    _waters11_group
except NameError as e:
    result = f"FAILED: {str(e)}"
except Exception as e:
    result = f"ERROR: {str(e)}"
result
`);

          if (testResult !== "SUCCESS") {
            throw new Error(`L·ªói kh·ªüi t·∫°o Waters11: ${testResult}`);
          }

          // ·∫®n loading overlay
          loadingOverlay.classList.remove("show");
          
          displayStatus(
            "Th∆∞ vi·ªán m√£ h√≥a ƒë√£ s·∫µn s√†ng. Vui l√≤ng t·∫£i l√™n Public Key.",
            "success"
          );
                publicKeyFileInput.disabled = false;
            } catch (error) {
          // ·∫®n loading overlay khi c√≥ l·ªói
          loadingOverlay.classList.remove("show");
          
                console.error("L·ªói kh·ªüi t·∫°o Pyodide ho·∫∑c Charm:", error);
          displayStatus(
            `L·ªói kh·ªüi t·∫°o th∆∞ vi·ªán m√£ h√≥a: ${error.message}. Trang s·∫Ω ho·∫°t ƒë·ªông m√† kh√¥ng c√≥ t√≠nh nƒÉng m√£ h√≥a.`,
            "error"
          );
          // Cho ph√©p submit m√† kh√¥ng m√£ h√≥a ƒë·ªÉ test
          submitButton.disabled = false;
            }
        }

        // --- Public Key Handling ---
      publicKeyFileInput.addEventListener("change", async (event) => {
            const file = event.target.files[0];
            if (!file) {
                publicKeyStatus.textContent = "Ch∆∞a ch·ªçn file.";
                abePublicKeyObject = null;
                return;
            }
        if (!pyodide) {
                displayStatus("Th∆∞ vi·ªán m√£ h√≥a ch∆∞a s·∫µn s√†ng.", "error");
                abePublicKeyObject = null;
                return;
            }

            publicKeyStatus.textContent = `ƒêang ƒë·ªçc file: ${file.name}...`;
            try {
          // Try both binary and JSON formats
          let publicKeyData = null;

          if (file.name.endsWith(".json")) {
            // JSON format
            const fileText = await file.text();
            try {
              publicKeyData = JSON.parse(fileText);
              if (!publicKeyData || typeof publicKeyData !== "object") {
                throw new Error("Public key JSON kh√¥ng h·ª£p l·ªá");
              }
            } catch (parseError) {
              throw new Error(`File JSON kh√¥ng h·ª£p l·ªá: ${parseError.message}`);
            }
          } else {
            // Binary format - deserialize using Charm-Crypto
                const fileBuffer = await file.arrayBuffer();
            const pkBytes = new Uint8Array(fileBuffer);



            // Use Pyodide to deserialize binary public key
            // Pass the bytes data to Pyodide's global namespace first
            const pkBytesArray = Array.from(pkBytes);
            pyodide.globals.set("js_pk_bytes_list", pkBytesArray);
            
            const result = await pyodide.runPythonAsync(`

import base64
import json
from charm.core.engine.util import bytesToObject

result_data = None
error_info = None

try:
    # Convert JS bytes to Python bytes - more efficient method
    pk_bytes_list = js_pk_bytes_list
    pk_bytes = bytes(pk_bytes_list)

    print(f"Received {len(pk_bytes)} bytes for public key deserialization")
    print(f"First 20 bytes: {pk_bytes[:20].hex()}")

    # Check if Charm group is available
    if '_waters11_group' not in globals():
        raise Exception("Waters11 group not initialized. Please reload Pyodide.")

    group = _waters11_group
    print("Using group:", group)

    # Deserialize using Charm
    pk_obj = bytesToObject(pk_bytes, group)
    print(f"Deserialized object type: {type(pk_obj)}")
    print(f"Deserialized object keys: {list(pk_obj.keys()) if hasattr(pk_obj, 'keys') else 'Not a dict'}")

    # Store the deserialized PK object in global for direct use in encryption
    globals()['_global_public_key_object'] = pk_obj

    # Also create a JSON representation for verification only
    pk_info = {
        "keys": list(pk_obj.keys()),
        "status": "loaded",
        "type": "charm_pk_object"
    }

    result_data = pk_info
    print(f"Successfully loaded public key with keys: {list(pk_obj.keys())}")
    print("Public key stored in global '_global_public_key_object'")

except Exception as e:
    error_info = str(e)
    print(f"Error deserializing public key: {e}")
    import traceback
    print(f"Traceback: {traceback.format_exc()}")

# Return result - ensure we actually return the JSON string
if result_data:
    result = json.dumps(result_data)
else:
    result = json.dumps({"error": error_info or "Unknown error"})

result

`);

            // Parse Python result

            let parsedResult;
            try {
              parsedResult = JSON.parse(result);
            } catch (parseError) {
              console.error("JSON Parse Error Details:");
              console.error("- Error message:", parseError.message);
              console.error(
                "- Raw result (first 200 chars):",
                result ? result.substring(0, 200) : "null"
              );
              console.error(
                "- Result as char codes:",
                result
                  ? Array.from(result.substring(0, 50)).map((c) =>
                      c.charCodeAt(0)
                    )
                  : "null"
              );
              throw new Error(
                `L·ªói parse k·∫øt qu·∫£ t·ª´ Python: ${parseError.message}`
              );
            }

            if (parsedResult.error) {
              throw new Error(`Python error: ${parsedResult.error}`);
            }

            if (!parsedResult || typeof parsedResult !== "object") {
              throw new Error("K·∫øt qu·∫£ deserialize kh√¥ng h·ª£p l·ªá");
            }

            if (
              parsedResult.status !== "loaded" ||
              parsedResult.type !== "charm_pk_object"
            ) {
              throw new Error("Public key kh√¥ng ƒë∆∞·ª£c load ƒë√∫ng c√°ch");
            }

            publicKeyData = parsedResult;
          }

          // Store the public key object for encryption
          abePublicKeyObject = publicKeyData;

                    publicKeyStatus.textContent = `ƒê√£ t·∫£i Public Key: ${file.name}`;
                    publicKeyStatus.style.color = "green";
          displayStatus(
            "Public Key ƒë√£ s·∫µn s√†ng. B·∫°n c√≥ th·ªÉ nh·∫≠p d·ªØ li·ªáu v√† ch√≠nh s√°ch.",
            "info"
          );
            } catch (error) {
                console.error("L·ªói x·ª≠ l√Ω Public Key:", error);
          console.error("Error details:", error);

          

          publicKeyStatus.textContent = `L·ªói: ${error.message}. Ki·ªÉm tra ƒë·ªãnh d·∫°ng file ho·∫∑c th·ª≠ file JSON.`;
                publicKeyStatus.style.color = "red";
                abePublicKeyObject = null;

          // Suggest alternatives
          displayStatus(
            `L·ªói x·ª≠ l√Ω public key: ${error.message}. Vui l√≤ng th·ª≠ file JSON format ho·∫∑c ki·ªÉm tra file binary c√≥ ƒë√∫ng ƒë·ªãnh d·∫°ng Charm-Crypto kh√¥ng.`,
            "error"
          );
            }
        });

        // --- Encryption Logic (Client-Side) ---
        async function encryptSensitiveContent(content, policyString, pkObject) {
        // Validate encryption inputs

        if (!pyodide) {
          console.error("pyodide is not available:", pyodide);
          throw new Error("H·ªá th·ªëng Pyodide ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o ƒë√∫ng c√°ch.");
        }

        if (!pkObject) {
          console.error("pkObject is not available:", pkObject);
          throw new Error("Thi·∫øu Public Key. Vui l√≤ng t·∫£i Public Key tr∆∞·ªõc.");
            }

            const aesKey = await crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
          true,
                ["encrypt", "decrypt"]
            );
        const aesKeyRaw = await crypto.subtle.exportKey("raw", aesKey);

        // 2. Convert AES key to hex string like medical_upload.js
        const aesKeyHex = arrayBufferToHexString(aesKeyRaw);

        // 3. Use the encryptAESKeyWithCPABE logic from medical_upload.js
        
        // Pass data to Pyodide globals to avoid template literal issues
        pyodide.globals.set("js_aes_key_hex", aesKeyHex);
        pyodide.globals.set("js_policy_string", policyString);

        let result;
        try {
          result = await pyodide.runPythonAsync(`

from charm.toolbox.pairinggroup import GT, G1, G2, ZR
import base64
import json
import hashlib

print("Python CP-ABE encryption started...")
final_result = None
try:
    # Check if objects exist
    print("Checking for stored objects...")
    if '_waters11_abe_scheme' not in globals():
        print("ERROR: _waters11_abe_scheme not found in globals!")
        raise Exception("Waters11 ABE scheme not initialized")
    if '_waters11_group' not in globals():
        print("ERROR: _waters11_group not found in globals!")
        raise Exception("Pairing group not initialized")

    # Use the stored objects
    waters_abe = _waters11_abe_scheme
    group = _waters11_group
    print("‚úì Using stored Waters11 ABE scheme and pairing group")

    # Use the stored public key object directly (no more reconstruction needed)
    if '_global_public_key_object' not in globals():
        print("ERROR: _global_public_key_object not found in globals!")
        raise Exception("Public key object not loaded")

    pk = _global_public_key_object  # This is the actual Charm PK object
    print(f"‚úì Using stored PK object with keys: {list(pk.keys())}")

    # Convert AES key hex to bytes
    aes_key_bytes = bytes.fromhex(js_aes_key_hex)

    # Create a consistent seed from the AES key using SHA256
    key_hash = hashlib.sha256(aes_key_bytes).digest()
    seed = int.from_bytes(key_hash[:4], byteorder='big')

    # Create GT message from the seed
    base_gt = group.pair_prod(pk['g1'], pk['g1'])
    gt_message = base_gt ** group.init(ZR, seed)

    # Calculate the key that will be used for Web Crypto
    web_crypto_key_bytes_for_data = hashlib.sha256(group.serialize(gt_message)).digest()
    web_crypto_key_base64_for_data = base64.b64encode(web_crypto_key_bytes_for_data).decode('utf-8')

    # Use the policy string with integer IDs
    policy_str = js_policy_string

    # Encrypt the GT message with CP-ABE
    print("Starting CP-ABE encryption...")
    ciphertext = waters_abe.encrypt(pk, gt_message, policy_str)
    print("‚úì CP-ABE encryption completed")
    print(f"‚úì Ciphertext keys: {list(ciphertext.keys())}")

    # Serialize ciphertext components separately to avoid BinNode serialization issues
    from charm.core.engine.util import objectToBytes

    # Create a serializable version of ciphertext without policy tree
    serializable_ct = {}
    for key, value in ciphertext.items():
        if key == 'policy':
            # Convert policy to string representation instead of BinNode
            serializable_ct[key] = str(value)
        else:
            # Keep other components as-is (they are serializable)
            serializable_ct[key] = value

    print(f"‚úì Serializable ciphertext keys: {list(serializable_ct.keys())}")

    # Now serialize the modified ciphertext
    serialized_ciphertext_bytes = objectToBytes(serializable_ct, group)
    encrypted_kek_final_b64 = base64.b64encode(serialized_ciphertext_bytes).decode('utf-8')
    print(f"‚úì Ciphertext serialized to {len(encrypted_kek_final_b64)} chars")

    # Return both encrypted KEK and derived key (theo analysis)
    result = {
        "abe_ciphertext_bundle_b64": encrypted_kek_final_b64,
        "web_crypto_aes_key_base64": web_crypto_key_base64_for_data
    }

except Exception as e:
    print(f"CP-ABE encryption failed: {e}")
    import traceback
    print(f"Traceback: {traceback.format_exc()}")
    result = None

# Serialize to JSON string for JavaScript
json.dumps(result)

`);
          console.log("Python execution completed");
        } catch (pythonError) {
          console.error("Python execution failed:", pythonError);
          console.error("Python error details:", pythonError.message);
          throw new Error(
            `L·ªói trong qu√° tr√¨nh m√£ h√≥a Python: ${pythonError.message}`
          );
        }

        console.log("Python result received, type:", typeof result);
        console.log("Python result length:", result ? result.length : "null");

        // Parse result from Python
        let parsedResult;
        try {
          parsedResult = JSON.parse(result);
        } catch (e) {
          throw new Error("L·ªói ƒë·ªãnh d·∫°ng k·∫øt qu·∫£ t·ª´ Python");
        }

        if (
          !parsedResult ||
          !parsedResult.abe_ciphertext_bundle_b64 ||
          !parsedResult.web_crypto_aes_key_base64
        ) {
          console.error("Invalid parsed result:", parsedResult);
          throw new Error("L·ªói m√£ h√≥a CP-ABE.");
        }

        // 4. Import derived key for data encryption
        const derivedKeyBytes = base64ToArrayBuffer(
          parsedResult.web_crypto_aes_key_base64
        );
        const derivedAesKey = await crypto.subtle.importKey(
          "raw",
          derivedKeyBytes,
          { name: "AES-GCM" },
          false,
          ["encrypt"]
        );

        // 5. Encrypt content with derived key
        const iv = crypto.getRandomValues(new Uint8Array(12));
            const encodedContent = new TextEncoder().encode(content);
        const encryptedContentBuffer = await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
          derivedAesKey,
                encodedContent
            );

            return {
          encryptedKekBase64: parsedResult.abe_ciphertext_bundle_b64, // ƒê√¢y l√† chu·ªói base64 duy nh·∫•t
          ivBase64: arrayBufferToBase64(iv),
          encryptedDataAesBase64: arrayBufferToBase64(encryptedContentBuffer),
        };
      }

      // Helper function like medical_upload.js
      function arrayBufferToHexString(buffer) {
        return Array.from(new Uint8Array(buffer))
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");
      }

      function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      }

      // Safe base64 encoding function for text with Unicode characters
      function safeBase64Encode(text) {
        try {
          // Method 1: Standard encoding for ASCII
          return btoa(text);
        } catch (error) {
          try {
            // Method 2: UTF-8 encoding for Unicode
            return btoa(unescape(encodeURIComponent(text)));
          } catch (error2) {
            // Method 3: TextEncoder fallback
            console.warn("Using TextEncoder fallback for base64 encoding");
            const encoder = new TextEncoder();
            const encodedData = encoder.encode(text);
            return arrayBufferToBase64(encodedData.buffer);
          }
        }
        }

        // --- Form Submit Handler ---
      ehrDataForm.addEventListener("submit", async function (event) {
            event.preventDefault();

            submitButton.disabled = true;
        submitButton.textContent = "ƒêang x·ª≠ l√Ω...";
        displayStatus("ƒêang chu·∫©n b·ªã d·ªØ li·ªáu...", "info");

        const patientId = document.getElementById("patientIdInput").value;
        const description = document.getElementById(
          "documentDescriptionInput"
        ).value;
        const dataType = document.getElementById("dataTypeSelect").value;
            const policyString = buildAndDisplayPolicyString();
            
            // Get content based on input mode
            let sensitiveContent;
            try {
              sensitiveContent = getContentForEncryption();
            } catch (error) {
              displayStatus(error.message, "error");
                submitButton.disabled = false;
              submitButton.textContent = "M√£ H√≥a v√† G·ª≠i D·ªØ Li·ªáu";
                return;
            }

            if (!policyString) {
          displayStatus(
            "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt thu·ªôc t√≠nh cho ch√≠nh s√°ch truy c·∫≠p.",
            "error"
          );
                submitButton.disabled = false;
          submitButton.textContent = "M√£ H√≥a v√† G·ª≠i D·ªØ Li·ªáu";
                return;
            }

            try {
          let payloadToServer;

          if (abePublicKeyObject && pyodide) {
            // C√≥ th·ªÉ m√£ h√≥a
            displayStatus("ƒêang m√£ h√≥a n·ªôi dung chi ti·∫øt...", "info");
            console.log("Starting encryption process...");
            console.log(
              "abePublicKeyObject keys:",
              Object.keys(abePublicKeyObject || {})
            );
            console.log("pyodide version:", pyodide.version);
            const encryptedBundle = await encryptSensitiveContent(
              sensitiveContent,
              policyString,
              abePublicKeyObject
            );

            payloadToServer = {
                    patient_id: patientId,
                    description: description,
                    data_type: dataType,
              cpabe_policy_applied: policyString,
                    encrypted_kek_b64: encryptedBundle.encryptedKekBase64,
                    aes_iv_b64: encryptedBundle.ivBase64,
              encrypted_main_content_b64:
                encryptedBundle.encryptedDataAesBase64,
            };
          } else {
            // Test mode - g·ª≠i d·ªØ li·ªáu dummy
            displayStatus("Ch·∫ø ƒë·ªô test - g·ª≠i d·ªØ li·ªáu kh√¥ng m√£ h√≥a...", "info");

            // Safe encoding for Vietnamese text
            const dummyBase64 = safeBase64Encode(sensitiveContent);

            payloadToServer = {
              patient_id: patientId,
              description: description,
              data_type: dataType,
              cpabe_policy_applied: policyString,
              encrypted_kek_b64: "dummy_kek_" + dummyBase64,
              aes_iv_b64: "dummy_iv_" + btoa("test_iv"),
              encrypted_main_content_b64: dummyBase64,
            };
          }

          displayStatus("ƒêang g·ª≠i l√™n server...", "info");

          // L·∫•y token t·ª´ localStorage ho·∫∑c cookie
          const accessToken =
            localStorage.getItem("mainServer_accessToken") ||
            localStorage.getItem("access_token") ||
            "dummy_token_for_test";

                const response = await fetch(UPLOAD_API_URL, {
            method: "POST",
                    headers: {
              Authorization: `Bearer ${accessToken}`,
              "Content-Type": "application/json",
                    },
            body: JSON.stringify(payloadToServer),
                });

                const responseData = await response.json();

                if (response.ok) {
            displayStatus(
              `G·ª≠i d·ªØ li·ªáu th√†nh c√¥ng! ID: ${responseData.entry_id || "N/A"}.`,
              "success"
            );
                    ehrDataForm.reset();
                    
                    // Reset file upload state
                    fileContentForEncryption = null;
                    fileStatus.textContent = "";
                    hideFilePreview();
                    currentInputMode = "text";
                    textModeRadio.checked = true;
                    textInputSection.style.display = "block";
                    fileInputSection.style.display = "none";
                    
                    buildAndDisplayPolicyString();
                } else {
            // Handle specific error cases
            let errorMessage =
              responseData.error || responseData.detail || response.statusText;

            if (response.status === 401) {
              errorMessage =
                "Token ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i t·ª´ Auth Center.";
            } else if (response.status === 403) {
              errorMessage =
                "Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p. Ki·ªÉm tra l·∫°i quy·ªÅn c·ªßa b·∫°n.";
            }

            displayStatus(
              `L·ªói t·ª´ server (${response.status}): ${errorMessage}`,
              "error"
            );
                }
            } catch (error) {
          console.error("L·ªói trong qu√° tr√¨nh x·ª≠ l√Ω:", error);
          console.error("Error stack:", error.stack);
          console.error("Error name:", error.name);

          let errorMessage = error.message || "Vui l√≤ng th·ª≠ l·∫°i.";
          if (error.name === "DOMException") {
            errorMessage = `L·ªói encoding d·ªØ li·ªáu: ${errorMessage}. Vui l√≤ng ki·ªÉm tra k√Ω t·ª± ƒë·∫∑c bi·ªát trong n·ªôi dung.`;
          }

          displayStatus(`L·ªói: ${errorMessage}`, "error");
            } finally {
                submitButton.disabled = false;
          submitButton.textContent = "M√£ H√≥a v√† G·ª≠i D·ªØ Li·ªáu";
            }
        });

      // --- Custom Attributes Event ---
      customAttributesElement.addEventListener(
        "input",
        buildAndDisplayPolicyString
      );

      // --- Token Validation ---
      async function checkTokenValidity() {
        const accessToken =
          localStorage.getItem("mainServer_accessToken") ||
          localStorage.getItem("access_token");

        if (!accessToken || accessToken === "dummy_token_for_test") {
          displayStatus(
            "Ch∆∞a c√≥ token h·ª£p l·ªá. Vui l√≤ng ƒëƒÉng nh·∫≠p t·ª´ Auth Center tr∆∞·ªõc.",
            "warning"
          );
          return false;
        }

        try {
          const response = await fetch("/api/auth/test/", {
            method: "GET",
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          });

          if (response.ok) {
            const data = await response.json();
            displayStatus(
              `Token h·ª£p l·ªá. ƒê√£ x√°c th·ª±c user: ${data.user_info.username}`,
              "success"
            );
            return true;
          } else {
            const errorData = await response.json();
            displayStatus(
              `Token kh√¥ng h·ª£p l·ªá: ${
                errorData.detail || "Unknown error"
              }. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.`,
              "error"
            );
            return false;
          }
        } catch (error) {
          console.error("Error checking token validity:", error);
          displayStatus("L·ªói ki·ªÉm tra token. Vui l√≤ng th·ª≠ l·∫°i.", "error");
          return false;
        }
      }

        // --- Initial Page Load ---
      document.addEventListener("DOMContentLoaded", async function () {
        
        // Ki·ªÉm tra authentication tr∆∞·ªõc khi cho ph√©p truy c·∫≠p trang
        const accessToken = localStorage.getItem("mainServer_accessToken") || 
                           localStorage.getItem("access_token");
        
        if (!accessToken || accessToken === "dummy_token_for_test") {
          displayStatus("‚ùå B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p! ƒêang chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p...", "error");
          setTimeout(() => {
            window.location.href = "/login/";
          }, 2000);
          return;
        }

        // Ki·ªÉm tra token validity
        const isTokenValid = await checkTokenValidity();
        if (!isTokenValid) {
          displayStatus("‚ùå Token kh√¥ng h·ª£p l·ªá! ƒêang chuy·ªÉn h∆∞·ªõng ƒë·∫øn trang ƒëƒÉng nh·∫≠p...", "error");
          // Clear invalid token
          localStorage.removeItem("mainServer_accessToken");
          localStorage.removeItem("access_token");
          setTimeout(() => {
            window.location.href = "/login/";
          }, 2000);
          return;
        }

        // Hi·ªÉn th·ªã th√¥ng tin user
        try {
          const response = await fetch("/api/auth/test/", {
            method: "GET",
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          });
          if (response.ok) {
            const data = await response.json();
            document.getElementById("currentUsername").textContent = data.user_info.username || "Unknown";
            document.getElementById("userHeader").style.display = "flex";
          }
        } catch (error) {
          console.error("Error fetching user info:", error);
        }

        generatePolicyUI();
        buildAndDisplayPolicyString();

        // Enable button cho test mode - kh√¥ng c·∫ßn ƒë·ª£i Pyodide
        submitButton.disabled = false;
        displayStatus("‚úÖ ƒê√£ x√°c th·ª±c th√†nh c√¥ng. Trang ƒë√£ s·∫µn s√†ng.", "success");

        publicKeyFileInput.disabled = true;
        await initializePyodide();
        });

      // --- Logout Function ---
      function logout() {
        // Clear tokens
        localStorage.removeItem("mainServer_accessToken");
        localStorage.removeItem("access_token");
        
        // Redirect to login
        displayStatus("ƒêang ƒëƒÉng xu·∫•t...", "info");
        setTimeout(() => {
          window.location.href = "/login/";
        }, 1000);
      }
    </script>
</body>
</html>